{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Troika is a collection of JavaScript tools for creating interactive graphics in the browser, with a focus on 3D/WebGL, and optimized for data visualization use cases. The provided tools fall into two main categories: The Troika Framework , a fully featured framework for managing entire scenes with rich interactivity and high performance, and A growing set of other tools for Three.js , that do not depend on that framework. The Troika project's main goal is to take aspects of developing interactive graphics that you almost always need, but are difficult to manage yourself, and make them as easy as possible. Troika Framework \u00b6 The Troika JavaScript framework is a system for managing complex imperative graphics APIs with a simple declarative model. It provides: A component architecture that encapsulates complex graphics APIs behind simple facade objects Declarative description of the scene's structure and how it should change over time CSS-like declarative animations and transitions DOM-like interaction event handling Performance optimizations At its core, the Troika framework manages a simple mapping from a declarative scene descriptor to a tree of special objects called Facades . Each Facade is a component that knows how to synchronize its state, set as flat properties by the scene descriptor, to a more complex underlying API. On top of that, Troika builds in some things like an event subscription model and declarative animations and transitions for facade properties. Learn more about Troika core concepts. Troika 3D \u00b6 Creating interactive 3D scenes with WebGL is Troika's first focus. It uses Three.js for the heavy lifting of managing WebGL state, and for its solid scene graph model, 3D primitives and math utilities, and shader library. Troika manages the Three.js renderer and common things like world matrix calculations and raycasting for pointer events. Otherwise, it has no knowledge of any 3D primitives; it's up to you to set up your Three.js meshes, geometries, materials, etc. and update them in your Object3DFacade implementations. A solid understanding of Three.js's model is therefore still required. As a very rough analogy: if Three.js provides a DOM for WebGL, then you could consider Troika to be like ReactJS for managing that DOM. It simplifies things, but you still need to know the DOM. Troika 3D also provides some more advanced capabilities like: position-synced HTML overlays , an easy-to-use GPU instancing abstraction, a system for creating flexbox user interfaces , and WebXR support . Learn more about Troika 3D. Troika 2D \u00b6 As a separate package, Troika also provides the ability to define graphics using the 2D Canvas API, using the same scene/facade patterns and core conveniences like animations and pointer events. This can be nice on its own when you don't need 3D, but is also useful as a graceful fallback for when WebGL isn't available in the browser. Learn more about Troika 2D. Troika Three.js Tools \u00b6 Over time, development of the Troika framework has produced certain tools and techniques that are generally useful for Three.js development. It has become our goal to extract as many of these tools as possible from the Troika framework so they can be used in pure Three.js projects or within other frameworks like AFrame or react-three-fiber. Some of these tools include: troika-three-text : High quality, high performance text rendering for Three.js. createDerivedMaterial : A utility for extending any Three.js material with custom shader code. InstancedUniformsMesh : An extension of Three's InstancedMesh that allows setting any shader uniform per instance. ...and others. Browser support \u00b6 Troika's framework and tools are generally intended to support in the same browsers as Three.js does. See the Three.js browser support docs for more details. All source files are ES2015 modules, and can be used un-transpiled in modern browsers supporting <script type=\"module\"> , though you'll probably still want to combine/tree-shake them with a module-aware build pipeline like Webpack or Rollup . For older browsers, ES5-transpiled files are provided. Origins \u00b6 Troika was developed starting in 2016 by the ProtectWise front end engineering team as an internal tool to enable rapid development of interactive 3D and 2D data visualizations in the ProtectWise Visualizer. As it matured and became an essential part of our toolkit, we realized it could be useful to the broader web developer community and decided to release it as an open source project in early 2019. Since then, ProtectWise has been acquired by Verizon Business , where Troika continues to be used for developing new 3D data visualizations on screens and in immersive WebXR environments.","title":"Overview"},{"location":"#troika-framework","text":"The Troika JavaScript framework is a system for managing complex imperative graphics APIs with a simple declarative model. It provides: A component architecture that encapsulates complex graphics APIs behind simple facade objects Declarative description of the scene's structure and how it should change over time CSS-like declarative animations and transitions DOM-like interaction event handling Performance optimizations At its core, the Troika framework manages a simple mapping from a declarative scene descriptor to a tree of special objects called Facades . Each Facade is a component that knows how to synchronize its state, set as flat properties by the scene descriptor, to a more complex underlying API. On top of that, Troika builds in some things like an event subscription model and declarative animations and transitions for facade properties. Learn more about Troika core concepts.","title":"Troika Framework"},{"location":"#troika-3d","text":"Creating interactive 3D scenes with WebGL is Troika's first focus. It uses Three.js for the heavy lifting of managing WebGL state, and for its solid scene graph model, 3D primitives and math utilities, and shader library. Troika manages the Three.js renderer and common things like world matrix calculations and raycasting for pointer events. Otherwise, it has no knowledge of any 3D primitives; it's up to you to set up your Three.js meshes, geometries, materials, etc. and update them in your Object3DFacade implementations. A solid understanding of Three.js's model is therefore still required. As a very rough analogy: if Three.js provides a DOM for WebGL, then you could consider Troika to be like ReactJS for managing that DOM. It simplifies things, but you still need to know the DOM. Troika 3D also provides some more advanced capabilities like: position-synced HTML overlays , an easy-to-use GPU instancing abstraction, a system for creating flexbox user interfaces , and WebXR support . Learn more about Troika 3D.","title":"Troika 3D"},{"location":"#troika-2d","text":"As a separate package, Troika also provides the ability to define graphics using the 2D Canvas API, using the same scene/facade patterns and core conveniences like animations and pointer events. This can be nice on its own when you don't need 3D, but is also useful as a graceful fallback for when WebGL isn't available in the browser. Learn more about Troika 2D.","title":"Troika 2D"},{"location":"#troika-threejs-tools","text":"Over time, development of the Troika framework has produced certain tools and techniques that are generally useful for Three.js development. It has become our goal to extract as many of these tools as possible from the Troika framework so they can be used in pure Three.js projects or within other frameworks like AFrame or react-three-fiber. Some of these tools include: troika-three-text : High quality, high performance text rendering for Three.js. createDerivedMaterial : A utility for extending any Three.js material with custom shader code. InstancedUniformsMesh : An extension of Three's InstancedMesh that allows setting any shader uniform per instance. ...and others.","title":"Troika Three.js Tools"},{"location":"#browser-support","text":"Troika's framework and tools are generally intended to support in the same browsers as Three.js does. See the Three.js browser support docs for more details. All source files are ES2015 modules, and can be used un-transpiled in modern browsers supporting <script type=\"module\"> , though you'll probably still want to combine/tree-shake them with a module-aware build pipeline like Webpack or Rollup . For older browsers, ES5-transpiled files are provided.","title":"Browser support"},{"location":"#origins","text":"Troika was developed starting in 2016 by the ProtectWise front end engineering team as an internal tool to enable rapid development of interactive 3D and 2D data visualizations in the ProtectWise Visualizer. As it matured and became an essential part of our toolkit, we realized it could be useful to the broader web developer community and decided to release it as an open source project in early 2019. Since then, ProtectWise has been acquired by Verizon Business , where Troika continues to be used for developing new 3D data visualizations on screens and in immersive WebXR environments.","title":"Origins"},{"location":"changelog/","text":"Change Log \u00b6 All notable changes to this project will be documented in this file. See Conventional Commits for commit guidelines. 0.45.0 (2022-01-02) \u00b6 Bug Fixes \u00b6 createDerivedMaterial: propagate the base material's customProgramCacheKey ( 9c8c6b1 ) Features \u00b6 troika-three-text: SDFs for all fonts are now stored in the same texture ( 7e871f7 ) Performance Improvements \u00b6 troika-three-text: avoid extra draw call on double sided materials as of Three r130 ( 6222ef3 ) troika-three-text: make the glyphColors buffer transferable ( c8c92fa ) 0.44.0 (2021-11-14) \u00b6 Bug Fixes \u00b6 troika-three-text: fill in missing caret positions when the final glyph is a ligature - #165 ( ad2eda6 ) 0.43.1-alpha.0 (2021-10-24) \u00b6 Bug Fixes \u00b6 troika-three-text: fix font parsing failures in iOS Safari ( a542b42 ) 0.43.0 (2021-09-20) \u00b6 Bug Fixes \u00b6 InstancedUniformsMesh: reuse same derived material instance when uniform names change ( bd7cea6 ), closes #154 remove warnings about many open worker module requests ( 164fb8f ), closes #156 Features \u00b6 troika-three-text: allow line wrapping after some common non-whitespace chars like hyphens ( 1b20e34 ), closes #136 troika-worker-utils: add a terminateWorker function ( 33b8455 ) don't transpile UMD build files, fixing usage with Three.js r128 ( e380b0d ), closes #130 Performance Improvements \u00b6 troika-three-text: parallelize SDF generation with multiple worker threads ( c2bf886 ) 0.42.0 (2021-05-17) \u00b6 Bug Fixes \u00b6 add three to peerDependencies in all leaf packages ( 0a11ab6 ) Features \u00b6 open up 'three' peer dependency to include future versions ( d4a5b23 ) 0.41.2 (2021-05-05) \u00b6 Bug Fixes \u00b6 update bidi-js for its ES5 build files ( 49ce5f2 ) 0.41.1 (2021-04-26) \u00b6 Bug Fixes \u00b6 update bidi-js for fix removing type:module from package.json ( 394c371 ) 0.41.0 (2021-04-19) \u00b6 Bug Fixes \u00b6 troika-core: set animation/transition first when using .update() ( 8ebf59d ) troika-three-text: fix Arabic word position letter forms ( 480ee97 ) troika-three-text: formatting characters no longer produce visible glyphs ( c0d28e8 ) troika-three-text: more correct impl for character joining types ( 2ce519a ) troika-three-text: prevent mutation of input to worldPositionToTextCoords method ( d487b8a ) Features \u00b6 update support up to threejs r127 ( 5b512f0 ) troika-three-text: add full bidi text support ( 3fde850 ) troika-three-text: simple bidi layout support, using explicit LRO/RLO/PDF chars only ( d511655 ) troika-three-text: very basic support for right-to-left text layout ( ce887be ) Performance Improvements \u00b6 prune some unused functions out of the Typr build ( 26e669f ) 0.40.0 (2021-02-28) \u00b6 Bug Fixes \u00b6 troika-three-text: fix boundingBox, boundingSphere, and raycasting with curveRadius ( 7cc7c82 ), closes #103 Features \u00b6 troika-3d: add initThreeObject lifecycle method to Object3DFacade ( 230a87d ) troika-3d: remove need for manually defining material.instanceUniforms ( a234f8c ) 0.39.2 (2021-02-18) \u00b6 Bug Fixes \u00b6 troika-three-text: fix shader error in WebGL1 ( cdbc7dc ), closes #108 0.39.1 (2021-02-17) \u00b6 Bug Fixes \u00b6 troika-three-text: selection rects no longer clip off trailing whitespace ( 158305c ), closes #78 0.39.0 (2021-02-15) \u00b6 Bug Fixes \u00b6 restore compatibility with three versions <0.113.0 by copying MathUtils.generateUUID ( 35856b5 ) Features \u00b6 troika-core: add requestRender method as nicer shortcut ( c79254c ) troika-three-text: add curveRadius for applying cylindrical curvature ( 6fdfbbf ) troika-three-text: export a function for debugging SDF textures ( 3fb0c23 ) troika-three-text: pack SDFs using all 4 color channels, to increase max glyphs in a texture ( d236caf ) troika-xr: add basic TeleportControls ( 319ed29 ) 0.38.1 (2021-02-03) \u00b6 Bug Fixes \u00b6 hoist vertexTransform defs to top of the shader to prevent errors in chained derivations ( 889ed38 ) update to support up to Three r125 ( 4edff04 ) three-instanced-uniforms-mesh: prevent creation of multiple derived geometries ( 94a7f67 ) three-instanced-uniforms-mesh: the derived material is now prototype-chained to its base ( bf45d01 ) troika-worker-utils: properly track open requests count ( a01d903 ) make derived material's customProgramCacheKey function writable ( 10289dd ) troika-three-text: prevent copy() from sharing geometry between instances ( 8c3ba2d ) add new text props to UI blocks ( a2d631f ) 0.38.0 (2021-01-24) \u00b6 Bug Fixes \u00b6 troika-three-text: allow negative percentages for outlineOffsetX/Y ( 3a274f0 ), closes #100 Features \u00b6 move InstancedUniformsMesh to its own three-instanced-uniforms-mesh package ( f623b1f ) 0.37.0 (2021-01-18) \u00b6 Features \u00b6 troika-three-text: added inner stroke and outline blur capabilities ( e004b9d ) add InstancedUniformsMesh class for setting shader uniforms per instance ( 5fd4d79 ) Performance Improvements \u00b6 troika-three-text: swap tiny-inflate to fflate for minor speed boost on woff fonts ( 2ae29fa ) 0.36.1 (2020-12-16) \u00b6 Bug Fixes \u00b6 troika-three-text: soften Typr.ts console warnings to debug level ( 50d951f ) troika-xr: destroy WristMountedUI contents when hidden ( 5589ee2 ) 0.36.0 (2020-12-04) \u00b6 Bug Fixes \u00b6 fix font parser build scripts ( e2d88fa ) prevent error in WristMountedUI when gripPose is null ( 755d560 ) use combined frustum for XR camera, using setProjectionFromUnion from three.js ( ff1b9ae ) troika-three-text: fix wrong caret position for collapsed ligature characters ( f220035 ) Features \u00b6 troika-three-text: fix kerning by updating from Typr.js to Typr.ts ( 43144cf ), closes #70 0.35.0 (2020-11-16) \u00b6 Features \u00b6 troika-xr: allow configuring framebufferScaleFactor, incl. ratios based on native ( f63c160 ) initial support for spring physics-based transitions ( 5e05bc8 ) 0.34.2 (2020-11-09) \u00b6 Bug Fixes \u00b6 troika-3d: prevent tree getting in bad state due to removal of orphanable children ( 8121425 ) troika-three-text: dispose the outline material when the base material is disposed ( 68bd2c8 ) troika-three-text: fix error when disposing the base material with outlines enabled ( 73a51f5 ) 0.34.1 (2020-10-20) \u00b6 Bug Fixes \u00b6 check for process env 'test' ( 4f7f8f2 ) check if process is undefined ( 2b6d56a ) 0.34.0 (2020-10-19) \u00b6 Bug Fixes \u00b6 troika-three-text: clipRect is no longer clamped to the text block's bounds ( 15edbd9 ) troika-three-text: fix text baseline being positioned too low ( 596d8ca ) troika-worker-utils: pre-transpile the .esm build - issue #84 ( 98248b6 ) Features \u00b6 troika-three-text: expose blockBounds and visibleBounds in textRenderInfo ( f3340ec ) troika-three-text: text outline and better antialiasing at small sizes ( 3836809 ) Performance Improvements \u00b6 micro-optimization of sdf texture insertion loop ( 995c2a6 ) 0.33.1 (2020-10-02) \u00b6 Note: Version bump only for package troika 0.33.0 (2020-10-02) \u00b6 Bug Fixes \u00b6 add \"sideEffects\":false to package.json files to assist treeshaking ( 61109b2 ) add PURE annotations to make troika-three-text treeshakeable ( 8e76b5c ) remove redundant \"browser\" and defunct \"jsnext:main\" fields from package.json files ( 0abec40 ) troika-three-text: make color prop only apply to that instance when sharing a base material ( da0f995 ) Features \u00b6 troika-three-text: modifications to the base material are now picked up automatically ( fc81d3a ) troika-three-utils: add chained option to createDerivedMaterial ( 2bfaa9c ) 0.32.0 (2020-09-16) \u00b6 Bug Fixes \u00b6 troika-three-utils: make derived material methods writable+configurable ( 4d4bfbc ), closes react-spring/drei#121 mutate boundingBox and set depth to 0 ( 1f9b6be ) Features \u00b6 added boundingBox calculation ( 140e9e8 ) 0.31.0 (2020-08-11) \u00b6 Bug Fixes \u00b6 troika-3d-ui: remove stray circular import ( 06be563 ) move Three.js peerDependency from troika-3d to troika-three-utils ( 96b6fc8 ) Features \u00b6 troika-3d: expose some new props for scene background and color management ( 5209f66 ) 0.30.2 (2020-07-22) \u00b6 Bug Fixes \u00b6 troika-three-text: prevent unbound buffer errors when disposing a GlyphsGeometry ( e860eac ), closes #69 react-spring/drei#62 0.30.1 (2020-07-19) \u00b6 Bug Fixes \u00b6 troika-3d-ui: fix inheritable props on text nodes, and add textIndent ( 0650c59 ) troika-three-text: fix changing text length in ThreeJS r117+ ( a7ef945 ), closes #69 0.30.0 (2020-07-16) \u00b6 Bug Fixes \u00b6 troika-worker-utils: decrease main thread message level from warn to log ( d7cee6d ) Features \u00b6 troika-three-text: add support for textIndent ( b689c0c ) extract flexbox layout logic to a new troika-flex-layout package ( 1b52fc9 ), closes #53 0.29.0 (2020-07-06) \u00b6 Bug Fixes \u00b6 troika-three-utils: fix program switching when double-deriving materials ( 89ed2f8 ) troika-xr: ensure correct initial transform of gltf objects on load ( 49287f3 ) Features \u00b6 troika-3d-text: add sdfGlyphSize option on TextMesh ( 978ef53 ), closes #58 troika-three-text: promote standalone text to a new troika-three-text package ( 995f2eb ), closes #47 0.28.1 (2020-06-17) \u00b6 Bug Fixes \u00b6 troika-3d-text: don't dispose derived materials on base material switch ( 3d88475 ), closes #59 troika-3d-text: set correct object in TextMesh raycast intersections ( 9f3eaa7 ), closes #62 Performance Improvements \u00b6 troika-three-utils: increase chance of program reuse in createDerivedMaterial ( 56daf65 ), closes #59 0.28.0 (2020-06-09) \u00b6 Bug Fixes \u00b6 troika-3d-text: fix cloning of TextMesh ( 13df49b ), closes #60 troika-3d-text: prevent double-derivation of text material ( ef8cffa ), closes #59 Features \u00b6 troika-3d-text: add glyphGeometryDetail parameter ( 1f7a11f ), closes #52 0.27.1 (2020-06-05) \u00b6 Bug Fixes \u00b6 troika-3d-text: fix shader error when casting shadows from text ( 0c9277d ) 0.27.0 (2020-06-02) \u00b6 Bug Fixes \u00b6 troika-3d-text: prevent error when transpiling down to es5 ( 7264b0c ), closes #51 Features \u00b6 troika-3d: add three.js r117 to supported version range ( 2761f39 ) troika-core: add update convenience method to all facades ( 7403be1 ) troika-examples: flexbox example: globe pokes through bg, add scrollable lists ( 074c620 ) 0.26.1 (2020-05-26) \u00b6 Bug Fixes \u00b6 troika-worker-modules: silence fallback warning in non-browser environments ( 3dedb8f ) 0.26.0 (2020-05-24) \u00b6 Bug Fixes \u00b6 troika-3d-text: #46 fix error on script load when document not present ( 1b005ec ) Features \u00b6 examples: add example showing a resizable flexbox layout ( 8f4d50d ) troika-3d-text: experimental colorRanges feature ( c4971c3 ) troika-worker-utils: add main thread fallback when web workers are not allowed ( c754d0b ) 0.25.0 (2020-05-19) \u00b6 Bug Fixes \u00b6 troika-3d: fix error in InstancingManager on uniforms with default value of 0 ( 8d2cc83 ) troika-3d: fix errors due to excessively deep BoundingSphereOctrees ( a4b5797 ), closes #42 troika-3d-text: avoid error if something tries to set textMaterial.shadowSide ( c09a3c1 ) Features \u00b6 troika-3d-text: add events fired on text sync start and completion ( 3e7d4e0 ) troika-3d-text: add original input parameters to textRenderInfo object ( e1ef963 ) troika-3d-text: publicly expose getCaretAtPoint and getSelectionRects functions ( 669b256 ) Performance Improvements \u00b6 troika-3d-text: improve speed of glyph SDF generation by ~15-20% ( 3718997 ) 0.24.1 (2020-05-04) \u00b6 Bug Fixes \u00b6 troika-3d-text: fix error parsing fonts with CFF glyph outlines; fixes #40 ( 0114ea6 ) 0.24.0 (2020-04-27) \u00b6 Bug Fixes \u00b6 troika-3d: default Plane and Circle primitives' side and shadowSide to DoubleSide ( 7704b0a ) troika-3d-text: change GlyphSegmentsQuadtree to not use class ( 7e4db6c ) troika-three-utils: allow use of the timeUniform within glsl functions ( 7354b9e ) Features \u00b6 troika-3d-text: add preloadFont utility ( acedd3c ), closes #39 troika-3d-text: add enhanced anchorX and anchorY config properties ( b58f7b9 ), closes #38 troika-3d-text: add some useful font metrics to textRenderInfo result ( c7b14b8 ) Performance Improvements \u00b6 troika-3d-text: major speed/memory improvement in text layout ( 1b65b33 ) troika-3d-text: micro optimizations in text layout ( c786397 ) troika-3d-text: optimize rendering of very long clipped text blocks ( c66fbec ) 0.23.0 (2020-04-16) \u00b6 Bug Fixes \u00b6 troika-3d-text: selection range rects now honor clipRect, and are instanced ( ba86004 ) troika-3d-ui: allow canceling drag-scroll behavior with e.preventDefault() ( eca5f15 ) troika-3d-ui: prevent sync of text nodes before flex layout finishes ( 4769cac ) troika-three-utils: fragmentColorTransform is now inserted prior to postprocessing chunks ( 97cd9ac ), closes #20 Features \u00b6 troika-3d-ui: add onAfterFlexLayoutApplied hook for FlexNode s ( 912f95c ) troika-3d-ui: allow overriding DatSelect dropdown styles/config ( bf78e79 ) troika-worker-modules: improve rehydration of functions in worker ( 8f63090 ), closes #31 Performance Improvements \u00b6 troika-3d-ui: make bg/border layers instanced, and move clipping to vertex shader ( f7526f4 ) 0.22.0 (2020-04-02) \u00b6 Bug Fixes \u00b6 examples: fix transparency of globe ( 8886bc1 ) examples: make bezier material doublesided ( 163b3e0 ) troika-3d-text: letterSpacing no longer applied after newlines ( 61cb4f8 ), closes #33 troika-xr: fix TargetRay transparency by rendering last w/o depth testing ( 045ec27 ) Features \u00b6 troika-3d-text: add 'orientation' parameter for defining default layout plane ( f2c0c76 ), closes #34 Performance Improvements \u00b6 troika-3d-text: move clipping logic from fragment to vertex shader ( 1accf78 ) troika-xr: avoid full update pass every frame in WristMountedUI ( 4a4cd16 ) troika-xr: avoid setting grip material colors every frame ( d3f1246 ) 0.21.0 (2020-03-27) \u00b6 Features \u00b6 examples: beziers: add instanceable version of the beziers, and add point light option ( 0739f4d ) troika-3d: instancing now supports custom derived materials ( bad5e02 ) troika-3d: reduce instancing batch size to 128 ( dc4bd8a ) troika-3d: update ThreeJS support up to r115 ( 531ff6a ) troika-three-utils: added new options for createDerivedMaterial ( d67bb4a ) troika-three-utils: derived shadow material uniforms are now synced automatically ( 7843f23 ) 0.20.0 (2020-03-16) \u00b6 Bug Fixes \u00b6 troika-3d-ui: fix scrollbars sometimes appearing inappropriately ( 010be47 ) troika-3d-ui: update children when first exiting clip rect ( 294f341 ) Features \u00b6 troika-3d-ui: allow dat-gui items to declare their own onUpdate ( a707fd5 ) troika-3d-ui: enable shadow casting by UI block bg/border layers ( d2c056c ) troika-worker-utils: export function for stringifying functions ( 977634b ) Performance Improvements \u00b6 skip updating children of inactive wrist-mounted ui ( c1b93f1 ) 0.19.0 (2020-02-28) \u00b6 Bug Fixes \u00b6 troika-xr: disable buggy experimental clickOnPoke feature ( 46cff53 ) Features \u00b6 examples: example configurators are standardized and work in XR ( cec6f63 ) troika-xr: improved default target ray appearance ( 3798d9e ) 0.19.0-alpha.0 (2020-02-22) \u00b6 Bug Fixes \u00b6 honor MeshFacade.autoDispose* when geometry or material changes ( f478a47 ) Features \u00b6 add a CircleFacade primitive ( d73ae87 ) troika-3d-ui: add DatGuiFacade and supporting widgets ( c463198 ) troika-xr: add WristMountedUI component ( 74f5b10 ) 0.18.0 (2020-02-21) \u00b6 Bug Fixes \u00b6 the PlaneFacade's geometry now faces up ( cb1bb1b ) Features \u00b6 Add a set of facades for common primitive meshes, using shared geometries and with setters for builtin material properties. ( d4b309b ) Add memoize function in utils ( 16efb01 ) troika-3d: allow passing a Vector3 instance to getCameraPosition ( f686483 )","title":"Changelog"},{"location":"changelog/#change-log","text":"All notable changes to this project will be documented in this file. See Conventional Commits for commit guidelines.","title":"Change Log"},{"location":"changelog/#0450-2022-01-02","text":"","title":"0.45.0 (2022-01-02)"},{"location":"changelog/#bug-fixes","text":"createDerivedMaterial: propagate the base material's customProgramCacheKey ( 9c8c6b1 )","title":"Bug Fixes"},{"location":"changelog/#features","text":"troika-three-text: SDFs for all fonts are now stored in the same texture ( 7e871f7 )","title":"Features"},{"location":"changelog/#performance-improvements","text":"troika-three-text: avoid extra draw call on double sided materials as of Three r130 ( 6222ef3 ) troika-three-text: make the glyphColors buffer transferable ( c8c92fa )","title":"Performance Improvements"},{"location":"changelog/#0440-2021-11-14","text":"","title":"0.44.0 (2021-11-14)"},{"location":"changelog/#bug-fixes_1","text":"troika-three-text: fill in missing caret positions when the final glyph is a ligature - #165 ( ad2eda6 )","title":"Bug Fixes"},{"location":"changelog/#0431-alpha0-2021-10-24","text":"","title":"0.43.1-alpha.0 (2021-10-24)"},{"location":"changelog/#bug-fixes_2","text":"troika-three-text: fix font parsing failures in iOS Safari ( a542b42 )","title":"Bug Fixes"},{"location":"changelog/#0430-2021-09-20","text":"","title":"0.43.0 (2021-09-20)"},{"location":"changelog/#bug-fixes_3","text":"InstancedUniformsMesh: reuse same derived material instance when uniform names change ( bd7cea6 ), closes #154 remove warnings about many open worker module requests ( 164fb8f ), closes #156","title":"Bug Fixes"},{"location":"changelog/#features_1","text":"troika-three-text: allow line wrapping after some common non-whitespace chars like hyphens ( 1b20e34 ), closes #136 troika-worker-utils: add a terminateWorker function ( 33b8455 ) don't transpile UMD build files, fixing usage with Three.js r128 ( e380b0d ), closes #130","title":"Features"},{"location":"changelog/#performance-improvements_1","text":"troika-three-text: parallelize SDF generation with multiple worker threads ( c2bf886 )","title":"Performance Improvements"},{"location":"changelog/#0420-2021-05-17","text":"","title":"0.42.0 (2021-05-17)"},{"location":"changelog/#bug-fixes_4","text":"add three to peerDependencies in all leaf packages ( 0a11ab6 )","title":"Bug Fixes"},{"location":"changelog/#features_2","text":"open up 'three' peer dependency to include future versions ( d4a5b23 )","title":"Features"},{"location":"changelog/#0412-2021-05-05","text":"","title":"0.41.2 (2021-05-05)"},{"location":"changelog/#bug-fixes_5","text":"update bidi-js for its ES5 build files ( 49ce5f2 )","title":"Bug Fixes"},{"location":"changelog/#0411-2021-04-26","text":"","title":"0.41.1 (2021-04-26)"},{"location":"changelog/#bug-fixes_6","text":"update bidi-js for fix removing type:module from package.json ( 394c371 )","title":"Bug Fixes"},{"location":"changelog/#0410-2021-04-19","text":"","title":"0.41.0 (2021-04-19)"},{"location":"changelog/#bug-fixes_7","text":"troika-core: set animation/transition first when using .update() ( 8ebf59d ) troika-three-text: fix Arabic word position letter forms ( 480ee97 ) troika-three-text: formatting characters no longer produce visible glyphs ( c0d28e8 ) troika-three-text: more correct impl for character joining types ( 2ce519a ) troika-three-text: prevent mutation of input to worldPositionToTextCoords method ( d487b8a )","title":"Bug Fixes"},{"location":"changelog/#features_3","text":"update support up to threejs r127 ( 5b512f0 ) troika-three-text: add full bidi text support ( 3fde850 ) troika-three-text: simple bidi layout support, using explicit LRO/RLO/PDF chars only ( d511655 ) troika-three-text: very basic support for right-to-left text layout ( ce887be )","title":"Features"},{"location":"changelog/#performance-improvements_2","text":"prune some unused functions out of the Typr build ( 26e669f )","title":"Performance Improvements"},{"location":"changelog/#0400-2021-02-28","text":"","title":"0.40.0 (2021-02-28)"},{"location":"changelog/#bug-fixes_8","text":"troika-three-text: fix boundingBox, boundingSphere, and raycasting with curveRadius ( 7cc7c82 ), closes #103","title":"Bug Fixes"},{"location":"changelog/#features_4","text":"troika-3d: add initThreeObject lifecycle method to Object3DFacade ( 230a87d ) troika-3d: remove need for manually defining material.instanceUniforms ( a234f8c )","title":"Features"},{"location":"changelog/#0392-2021-02-18","text":"","title":"0.39.2 (2021-02-18)"},{"location":"changelog/#bug-fixes_9","text":"troika-three-text: fix shader error in WebGL1 ( cdbc7dc ), closes #108","title":"Bug Fixes"},{"location":"changelog/#0391-2021-02-17","text":"","title":"0.39.1 (2021-02-17)"},{"location":"changelog/#bug-fixes_10","text":"troika-three-text: selection rects no longer clip off trailing whitespace ( 158305c ), closes #78","title":"Bug Fixes"},{"location":"changelog/#0390-2021-02-15","text":"","title":"0.39.0 (2021-02-15)"},{"location":"changelog/#bug-fixes_11","text":"restore compatibility with three versions <0.113.0 by copying MathUtils.generateUUID ( 35856b5 )","title":"Bug Fixes"},{"location":"changelog/#features_5","text":"troika-core: add requestRender method as nicer shortcut ( c79254c ) troika-three-text: add curveRadius for applying cylindrical curvature ( 6fdfbbf ) troika-three-text: export a function for debugging SDF textures ( 3fb0c23 ) troika-three-text: pack SDFs using all 4 color channels, to increase max glyphs in a texture ( d236caf ) troika-xr: add basic TeleportControls ( 319ed29 )","title":"Features"},{"location":"changelog/#0381-2021-02-03","text":"","title":"0.38.1 (2021-02-03)"},{"location":"changelog/#bug-fixes_12","text":"hoist vertexTransform defs to top of the shader to prevent errors in chained derivations ( 889ed38 ) update to support up to Three r125 ( 4edff04 ) three-instanced-uniforms-mesh: prevent creation of multiple derived geometries ( 94a7f67 ) three-instanced-uniforms-mesh: the derived material is now prototype-chained to its base ( bf45d01 ) troika-worker-utils: properly track open requests count ( a01d903 ) make derived material's customProgramCacheKey function writable ( 10289dd ) troika-three-text: prevent copy() from sharing geometry between instances ( 8c3ba2d ) add new text props to UI blocks ( a2d631f )","title":"Bug Fixes"},{"location":"changelog/#0380-2021-01-24","text":"","title":"0.38.0 (2021-01-24)"},{"location":"changelog/#bug-fixes_13","text":"troika-three-text: allow negative percentages for outlineOffsetX/Y ( 3a274f0 ), closes #100","title":"Bug Fixes"},{"location":"changelog/#features_6","text":"move InstancedUniformsMesh to its own three-instanced-uniforms-mesh package ( f623b1f )","title":"Features"},{"location":"changelog/#0370-2021-01-18","text":"","title":"0.37.0 (2021-01-18)"},{"location":"changelog/#features_7","text":"troika-three-text: added inner stroke and outline blur capabilities ( e004b9d ) add InstancedUniformsMesh class for setting shader uniforms per instance ( 5fd4d79 )","title":"Features"},{"location":"changelog/#performance-improvements_3","text":"troika-three-text: swap tiny-inflate to fflate for minor speed boost on woff fonts ( 2ae29fa )","title":"Performance Improvements"},{"location":"changelog/#0361-2020-12-16","text":"","title":"0.36.1 (2020-12-16)"},{"location":"changelog/#bug-fixes_14","text":"troika-three-text: soften Typr.ts console warnings to debug level ( 50d951f ) troika-xr: destroy WristMountedUI contents when hidden ( 5589ee2 )","title":"Bug Fixes"},{"location":"changelog/#0360-2020-12-04","text":"","title":"0.36.0 (2020-12-04)"},{"location":"changelog/#bug-fixes_15","text":"fix font parser build scripts ( e2d88fa ) prevent error in WristMountedUI when gripPose is null ( 755d560 ) use combined frustum for XR camera, using setProjectionFromUnion from three.js ( ff1b9ae ) troika-three-text: fix wrong caret position for collapsed ligature characters ( f220035 )","title":"Bug Fixes"},{"location":"changelog/#features_8","text":"troika-three-text: fix kerning by updating from Typr.js to Typr.ts ( 43144cf ), closes #70","title":"Features"},{"location":"changelog/#0350-2020-11-16","text":"","title":"0.35.0 (2020-11-16)"},{"location":"changelog/#features_9","text":"troika-xr: allow configuring framebufferScaleFactor, incl. ratios based on native ( f63c160 ) initial support for spring physics-based transitions ( 5e05bc8 )","title":"Features"},{"location":"changelog/#0342-2020-11-09","text":"","title":"0.34.2 (2020-11-09)"},{"location":"changelog/#bug-fixes_16","text":"troika-3d: prevent tree getting in bad state due to removal of orphanable children ( 8121425 ) troika-three-text: dispose the outline material when the base material is disposed ( 68bd2c8 ) troika-three-text: fix error when disposing the base material with outlines enabled ( 73a51f5 )","title":"Bug Fixes"},{"location":"changelog/#0341-2020-10-20","text":"","title":"0.34.1 (2020-10-20)"},{"location":"changelog/#bug-fixes_17","text":"check for process env 'test' ( 4f7f8f2 ) check if process is undefined ( 2b6d56a )","title":"Bug Fixes"},{"location":"changelog/#0340-2020-10-19","text":"","title":"0.34.0 (2020-10-19)"},{"location":"changelog/#bug-fixes_18","text":"troika-three-text: clipRect is no longer clamped to the text block's bounds ( 15edbd9 ) troika-three-text: fix text baseline being positioned too low ( 596d8ca ) troika-worker-utils: pre-transpile the .esm build - issue #84 ( 98248b6 )","title":"Bug Fixes"},{"location":"changelog/#features_10","text":"troika-three-text: expose blockBounds and visibleBounds in textRenderInfo ( f3340ec ) troika-three-text: text outline and better antialiasing at small sizes ( 3836809 )","title":"Features"},{"location":"changelog/#performance-improvements_4","text":"micro-optimization of sdf texture insertion loop ( 995c2a6 )","title":"Performance Improvements"},{"location":"changelog/#0331-2020-10-02","text":"Note: Version bump only for package troika","title":"0.33.1 (2020-10-02)"},{"location":"changelog/#0330-2020-10-02","text":"","title":"0.33.0 (2020-10-02)"},{"location":"changelog/#bug-fixes_19","text":"add \"sideEffects\":false to package.json files to assist treeshaking ( 61109b2 ) add PURE annotations to make troika-three-text treeshakeable ( 8e76b5c ) remove redundant \"browser\" and defunct \"jsnext:main\" fields from package.json files ( 0abec40 ) troika-three-text: make color prop only apply to that instance when sharing a base material ( da0f995 )","title":"Bug Fixes"},{"location":"changelog/#features_11","text":"troika-three-text: modifications to the base material are now picked up automatically ( fc81d3a ) troika-three-utils: add chained option to createDerivedMaterial ( 2bfaa9c )","title":"Features"},{"location":"changelog/#0320-2020-09-16","text":"","title":"0.32.0 (2020-09-16)"},{"location":"changelog/#bug-fixes_20","text":"troika-three-utils: make derived material methods writable+configurable ( 4d4bfbc ), closes react-spring/drei#121 mutate boundingBox and set depth to 0 ( 1f9b6be )","title":"Bug Fixes"},{"location":"changelog/#features_12","text":"added boundingBox calculation ( 140e9e8 )","title":"Features"},{"location":"changelog/#0310-2020-08-11","text":"","title":"0.31.0 (2020-08-11)"},{"location":"changelog/#bug-fixes_21","text":"troika-3d-ui: remove stray circular import ( 06be563 ) move Three.js peerDependency from troika-3d to troika-three-utils ( 96b6fc8 )","title":"Bug Fixes"},{"location":"changelog/#features_13","text":"troika-3d: expose some new props for scene background and color management ( 5209f66 )","title":"Features"},{"location":"changelog/#0302-2020-07-22","text":"","title":"0.30.2 (2020-07-22)"},{"location":"changelog/#bug-fixes_22","text":"troika-three-text: prevent unbound buffer errors when disposing a GlyphsGeometry ( e860eac ), closes #69 react-spring/drei#62","title":"Bug Fixes"},{"location":"changelog/#0301-2020-07-19","text":"","title":"0.30.1 (2020-07-19)"},{"location":"changelog/#bug-fixes_23","text":"troika-3d-ui: fix inheritable props on text nodes, and add textIndent ( 0650c59 ) troika-three-text: fix changing text length in ThreeJS r117+ ( a7ef945 ), closes #69","title":"Bug Fixes"},{"location":"changelog/#0300-2020-07-16","text":"","title":"0.30.0 (2020-07-16)"},{"location":"changelog/#bug-fixes_24","text":"troika-worker-utils: decrease main thread message level from warn to log ( d7cee6d )","title":"Bug Fixes"},{"location":"changelog/#features_14","text":"troika-three-text: add support for textIndent ( b689c0c ) extract flexbox layout logic to a new troika-flex-layout package ( 1b52fc9 ), closes #53","title":"Features"},{"location":"changelog/#0290-2020-07-06","text":"","title":"0.29.0 (2020-07-06)"},{"location":"changelog/#bug-fixes_25","text":"troika-three-utils: fix program switching when double-deriving materials ( 89ed2f8 ) troika-xr: ensure correct initial transform of gltf objects on load ( 49287f3 )","title":"Bug Fixes"},{"location":"changelog/#features_15","text":"troika-3d-text: add sdfGlyphSize option on TextMesh ( 978ef53 ), closes #58 troika-three-text: promote standalone text to a new troika-three-text package ( 995f2eb ), closes #47","title":"Features"},{"location":"changelog/#0281-2020-06-17","text":"","title":"0.28.1 (2020-06-17)"},{"location":"changelog/#bug-fixes_26","text":"troika-3d-text: don't dispose derived materials on base material switch ( 3d88475 ), closes #59 troika-3d-text: set correct object in TextMesh raycast intersections ( 9f3eaa7 ), closes #62","title":"Bug Fixes"},{"location":"changelog/#performance-improvements_5","text":"troika-three-utils: increase chance of program reuse in createDerivedMaterial ( 56daf65 ), closes #59","title":"Performance Improvements"},{"location":"changelog/#0280-2020-06-09","text":"","title":"0.28.0 (2020-06-09)"},{"location":"changelog/#bug-fixes_27","text":"troika-3d-text: fix cloning of TextMesh ( 13df49b ), closes #60 troika-3d-text: prevent double-derivation of text material ( ef8cffa ), closes #59","title":"Bug Fixes"},{"location":"changelog/#features_16","text":"troika-3d-text: add glyphGeometryDetail parameter ( 1f7a11f ), closes #52","title":"Features"},{"location":"changelog/#0271-2020-06-05","text":"","title":"0.27.1 (2020-06-05)"},{"location":"changelog/#bug-fixes_28","text":"troika-3d-text: fix shader error when casting shadows from text ( 0c9277d )","title":"Bug Fixes"},{"location":"changelog/#0270-2020-06-02","text":"","title":"0.27.0 (2020-06-02)"},{"location":"changelog/#bug-fixes_29","text":"troika-3d-text: prevent error when transpiling down to es5 ( 7264b0c ), closes #51","title":"Bug Fixes"},{"location":"changelog/#features_17","text":"troika-3d: add three.js r117 to supported version range ( 2761f39 ) troika-core: add update convenience method to all facades ( 7403be1 ) troika-examples: flexbox example: globe pokes through bg, add scrollable lists ( 074c620 )","title":"Features"},{"location":"changelog/#0261-2020-05-26","text":"","title":"0.26.1 (2020-05-26)"},{"location":"changelog/#bug-fixes_30","text":"troika-worker-modules: silence fallback warning in non-browser environments ( 3dedb8f )","title":"Bug Fixes"},{"location":"changelog/#0260-2020-05-24","text":"","title":"0.26.0 (2020-05-24)"},{"location":"changelog/#bug-fixes_31","text":"troika-3d-text: #46 fix error on script load when document not present ( 1b005ec )","title":"Bug Fixes"},{"location":"changelog/#features_18","text":"examples: add example showing a resizable flexbox layout ( 8f4d50d ) troika-3d-text: experimental colorRanges feature ( c4971c3 ) troika-worker-utils: add main thread fallback when web workers are not allowed ( c754d0b )","title":"Features"},{"location":"changelog/#0250-2020-05-19","text":"","title":"0.25.0 (2020-05-19)"},{"location":"changelog/#bug-fixes_32","text":"troika-3d: fix error in InstancingManager on uniforms with default value of 0 ( 8d2cc83 ) troika-3d: fix errors due to excessively deep BoundingSphereOctrees ( a4b5797 ), closes #42 troika-3d-text: avoid error if something tries to set textMaterial.shadowSide ( c09a3c1 )","title":"Bug Fixes"},{"location":"changelog/#features_19","text":"troika-3d-text: add events fired on text sync start and completion ( 3e7d4e0 ) troika-3d-text: add original input parameters to textRenderInfo object ( e1ef963 ) troika-3d-text: publicly expose getCaretAtPoint and getSelectionRects functions ( 669b256 )","title":"Features"},{"location":"changelog/#performance-improvements_6","text":"troika-3d-text: improve speed of glyph SDF generation by ~15-20% ( 3718997 )","title":"Performance Improvements"},{"location":"changelog/#0241-2020-05-04","text":"","title":"0.24.1 (2020-05-04)"},{"location":"changelog/#bug-fixes_33","text":"troika-3d-text: fix error parsing fonts with CFF glyph outlines; fixes #40 ( 0114ea6 )","title":"Bug Fixes"},{"location":"changelog/#0240-2020-04-27","text":"","title":"0.24.0 (2020-04-27)"},{"location":"changelog/#bug-fixes_34","text":"troika-3d: default Plane and Circle primitives' side and shadowSide to DoubleSide ( 7704b0a ) troika-3d-text: change GlyphSegmentsQuadtree to not use class ( 7e4db6c ) troika-three-utils: allow use of the timeUniform within glsl functions ( 7354b9e )","title":"Bug Fixes"},{"location":"changelog/#features_20","text":"troika-3d-text: add preloadFont utility ( acedd3c ), closes #39 troika-3d-text: add enhanced anchorX and anchorY config properties ( b58f7b9 ), closes #38 troika-3d-text: add some useful font metrics to textRenderInfo result ( c7b14b8 )","title":"Features"},{"location":"changelog/#performance-improvements_7","text":"troika-3d-text: major speed/memory improvement in text layout ( 1b65b33 ) troika-3d-text: micro optimizations in text layout ( c786397 ) troika-3d-text: optimize rendering of very long clipped text blocks ( c66fbec )","title":"Performance Improvements"},{"location":"changelog/#0230-2020-04-16","text":"","title":"0.23.0 (2020-04-16)"},{"location":"changelog/#bug-fixes_35","text":"troika-3d-text: selection range rects now honor clipRect, and are instanced ( ba86004 ) troika-3d-ui: allow canceling drag-scroll behavior with e.preventDefault() ( eca5f15 ) troika-3d-ui: prevent sync of text nodes before flex layout finishes ( 4769cac ) troika-three-utils: fragmentColorTransform is now inserted prior to postprocessing chunks ( 97cd9ac ), closes #20","title":"Bug Fixes"},{"location":"changelog/#features_21","text":"troika-3d-ui: add onAfterFlexLayoutApplied hook for FlexNode s ( 912f95c ) troika-3d-ui: allow overriding DatSelect dropdown styles/config ( bf78e79 ) troika-worker-modules: improve rehydration of functions in worker ( 8f63090 ), closes #31","title":"Features"},{"location":"changelog/#performance-improvements_8","text":"troika-3d-ui: make bg/border layers instanced, and move clipping to vertex shader ( f7526f4 )","title":"Performance Improvements"},{"location":"changelog/#0220-2020-04-02","text":"","title":"0.22.0 (2020-04-02)"},{"location":"changelog/#bug-fixes_36","text":"examples: fix transparency of globe ( 8886bc1 ) examples: make bezier material doublesided ( 163b3e0 ) troika-3d-text: letterSpacing no longer applied after newlines ( 61cb4f8 ), closes #33 troika-xr: fix TargetRay transparency by rendering last w/o depth testing ( 045ec27 )","title":"Bug Fixes"},{"location":"changelog/#features_22","text":"troika-3d-text: add 'orientation' parameter for defining default layout plane ( f2c0c76 ), closes #34","title":"Features"},{"location":"changelog/#performance-improvements_9","text":"troika-3d-text: move clipping logic from fragment to vertex shader ( 1accf78 ) troika-xr: avoid full update pass every frame in WristMountedUI ( 4a4cd16 ) troika-xr: avoid setting grip material colors every frame ( d3f1246 )","title":"Performance Improvements"},{"location":"changelog/#0210-2020-03-27","text":"","title":"0.21.0 (2020-03-27)"},{"location":"changelog/#features_23","text":"examples: beziers: add instanceable version of the beziers, and add point light option ( 0739f4d ) troika-3d: instancing now supports custom derived materials ( bad5e02 ) troika-3d: reduce instancing batch size to 128 ( dc4bd8a ) troika-3d: update ThreeJS support up to r115 ( 531ff6a ) troika-three-utils: added new options for createDerivedMaterial ( d67bb4a ) troika-three-utils: derived shadow material uniforms are now synced automatically ( 7843f23 )","title":"Features"},{"location":"changelog/#0200-2020-03-16","text":"","title":"0.20.0 (2020-03-16)"},{"location":"changelog/#bug-fixes_37","text":"troika-3d-ui: fix scrollbars sometimes appearing inappropriately ( 010be47 ) troika-3d-ui: update children when first exiting clip rect ( 294f341 )","title":"Bug Fixes"},{"location":"changelog/#features_24","text":"troika-3d-ui: allow dat-gui items to declare their own onUpdate ( a707fd5 ) troika-3d-ui: enable shadow casting by UI block bg/border layers ( d2c056c ) troika-worker-utils: export function for stringifying functions ( 977634b )","title":"Features"},{"location":"changelog/#performance-improvements_10","text":"skip updating children of inactive wrist-mounted ui ( c1b93f1 )","title":"Performance Improvements"},{"location":"changelog/#0190-2020-02-28","text":"","title":"0.19.0 (2020-02-28)"},{"location":"changelog/#bug-fixes_38","text":"troika-xr: disable buggy experimental clickOnPoke feature ( 46cff53 )","title":"Bug Fixes"},{"location":"changelog/#features_25","text":"examples: example configurators are standardized and work in XR ( cec6f63 ) troika-xr: improved default target ray appearance ( 3798d9e )","title":"Features"},{"location":"changelog/#0190-alpha0-2020-02-22","text":"","title":"0.19.0-alpha.0 (2020-02-22)"},{"location":"changelog/#bug-fixes_39","text":"honor MeshFacade.autoDispose* when geometry or material changes ( f478a47 )","title":"Bug Fixes"},{"location":"changelog/#features_26","text":"add a CircleFacade primitive ( d73ae87 ) troika-3d-ui: add DatGuiFacade and supporting widgets ( c463198 ) troika-xr: add WristMountedUI component ( 74f5b10 )","title":"Features"},{"location":"changelog/#0180-2020-02-21","text":"","title":"0.18.0 (2020-02-21)"},{"location":"changelog/#bug-fixes_40","text":"the PlaneFacade's geometry now faces up ( cb1bb1b )","title":"Bug Fixes"},{"location":"changelog/#features_27","text":"Add a set of facades for common primitive meshes, using shared geometries and with setters for builtin material properties. ( d4b309b ) Add memoize function in utils ( 16efb01 ) troika-3d: allow passing a Vector3 instance to getCameraPosition ( f686483 )","title":"Features"},{"location":"getting-started/examples/","text":"The troika-examples package contains several example scenes. These are intended to demonstrate a wide range of Troika's capabilities and some interesting techniques that it enables. Viewing the examples \u00b6 The examples from the latest master branch are published automatically at https://troika-examples.netlify.com . Running the examples \u00b6 You can run the examples yourself from the source code. First check out the source from GitHub and install the dependencies: git clone https://github.com/protectwise/troika.git cd troika npm install Then run the examples: npm run examples This will build the examples into a bundle and serve up the result at [http://localhost:10001]. Point your browser there and you'll see the examples in action. It will also watch the files for changes so you can fiddle with things and reload the browser to see them in action.","title":"Examples"},{"location":"getting-started/examples/#viewing-the-examples","text":"The examples from the latest master branch are published automatically at https://troika-examples.netlify.com .","title":"Viewing the examples"},{"location":"getting-started/examples/#running-the-examples","text":"You can run the examples yourself from the source code. First check out the source from GitHub and install the dependencies: git clone https://github.com/protectwise/troika.git cd troika npm install Then run the examples: npm run examples This will build the examples into a bundle and serve up the result at [http://localhost:10001]. Point your browser there and you'll see the examples in action. It will also watch the files for changes so you can fiddle with things and reload the browser to see them in action.","title":"Running the examples"},{"location":"getting-started/setup/","text":"Installation \u00b6 Troika is separated into multiple NPM packages depending on your specific needs. For the common case of creating a 3D scene, do: npm install troika-3d Additional optional packages can also be installed as needed: npm install troika-2d npm install troika-3d-text etc... Dependencies \u00b6 Three.js \u00b6 The packages related to 3D require three ( Three.js ) as a peer dependency, which means you will have to declare three as a dependency in your own project. npm install --save three The allowed version range for three is open-ended, so you should be able to use any relatively recent version without issues. However, Three.js releases do often contain breaking changes which may introduce incompatibilities in the future. While we try to test against recent three versions on a regular basis, some of these may slip by our notice; if you find one, please open an issue for us. React \u00b6 Assuming you want to use the React component wrappers ( Canvas3D etc.), you'll also need to add react and react-dom to your project's dependencies if not already there: npm install --save react react-dom You don't need to do this if you're using Troika without the React wrappers (impressive!) or are just using some of its utilities. Importing \u00b6 You should now be able to import from troika-3d as needed... as ES2015 modules \u00b6 import { Canvas3D , Object3DFacade } from 'troika-3d' as CommonJS modules \u00b6 const { Canvas3D , Object3DFacade } = require ( 'troika-3d' ) as globals \u00b6 If you are not using a module-aware build pipeline, Troika's UMD bundles expose globals you can use instead; you'll need to include the proper dependencies manually. Note: This usage pattern is not well tested; please report bugs with it. < script > var Canvas3D = troika_3d . Canvas3D ; var Object3DFacade = troika_3d . Object3DFacade ; //... </ script > Source Code Checkout \u00b6 If you want to work with the source code or run the examples locally, clone it from the GitHub repository: git clone https://github.com/protectwise/troika.git cd troika npm install","title":"Setup"},{"location":"getting-started/setup/#installation","text":"Troika is separated into multiple NPM packages depending on your specific needs. For the common case of creating a 3D scene, do: npm install troika-3d Additional optional packages can also be installed as needed: npm install troika-2d npm install troika-3d-text etc...","title":"Installation"},{"location":"getting-started/setup/#dependencies","text":"","title":"Dependencies"},{"location":"getting-started/setup/#threejs","text":"The packages related to 3D require three ( Three.js ) as a peer dependency, which means you will have to declare three as a dependency in your own project. npm install --save three The allowed version range for three is open-ended, so you should be able to use any relatively recent version without issues. However, Three.js releases do often contain breaking changes which may introduce incompatibilities in the future. While we try to test against recent three versions on a regular basis, some of these may slip by our notice; if you find one, please open an issue for us.","title":"Three.js"},{"location":"getting-started/setup/#react","text":"Assuming you want to use the React component wrappers ( Canvas3D etc.), you'll also need to add react and react-dom to your project's dependencies if not already there: npm install --save react react-dom You don't need to do this if you're using Troika without the React wrappers (impressive!) or are just using some of its utilities.","title":"React"},{"location":"getting-started/setup/#importing","text":"You should now be able to import from troika-3d as needed...","title":"Importing"},{"location":"getting-started/setup/#as-es2015-modules","text":"import { Canvas3D , Object3DFacade } from 'troika-3d'","title":"as ES2015 modules"},{"location":"getting-started/setup/#as-commonjs-modules","text":"const { Canvas3D , Object3DFacade } = require ( 'troika-3d' )","title":"as CommonJS modules"},{"location":"getting-started/setup/#as-globals","text":"If you are not using a module-aware build pipeline, Troika's UMD bundles expose globals you can use instead; you'll need to include the proper dependencies manually. Note: This usage pattern is not well tested; please report bugs with it. < script > var Canvas3D = troika_3d . Canvas3D ; var Object3DFacade = troika_3d . Object3DFacade ; //... </ script >","title":"as globals"},{"location":"getting-started/setup/#source-code-checkout","text":"If you want to work with the source code or run the examples locally, clone it from the GitHub repository: git clone https://github.com/protectwise/troika.git cd troika npm install","title":"Source Code Checkout"},{"location":"three-instanced-uniforms-mesh/","text":"InstancedUniformsMesh \u00b6 This package provides a InstancedUniformsMesh class which extends Three.js's InstancedMesh to allow its material's shader uniforms to be set individually per instance. It behaves just like InstancedMesh but exposes a new method: mesh . setUniformAt ( uniformName , instanceIndex , value ) When you call setUniformAt , the geometry and the material's shaders will be automatically upgraded behind the scenes to turn that uniform into an instanced buffer attribute, filling in the other indices with the uniform's default value. You can do this for any uniform of type float , vec2 , vec3 , or vec4 . It works both for built-in Three.js materials and also for any custom ShaderMaterial. For example, here is how you could set random emissive and metalness values for each instance using a MeshStandardMaterial : import { InstancedUniformsMesh } from 'three-instanced-uniforms-mesh' const count = 100 const mesh = new InstancedUniformsMesh ( someGeometry , new MeshStandardMaterial (), count ) const color = new Color () for ( let i = 0 ; i < count ; i ++ ) { mesh . setMatrixAt ( i , someMatrixValue ) mesh . setUniformAt ( 'metalness' , i , Math . random ()) mesh . setUniformAt ( 'emissive' , i , color . set ( Math . random () * 0xffffff )) } While this is obviously useful for Three.js's built in materials, it really shines with custom shaders. Just declare any configurable parameters as uniforms in your custom shader, and then you can use that either on a single non-instanced Mesh by setting the material's uniforms directly, or instance it using InstancedUniformsMesh by calling setUniformAt . Your shader doesn't need to change at all to support the instancing! Note: Calling setUniformAt automatically marks the underlying buffer attributes for upload, so unlike setMatrixAt or setColorAt you don't need to set needsUpdate manually. Value Types \u00b6 The type of the value argument should match the type of the uniform defined in the material's shader: For a uniform of type: Pass a value of this type: float Number vec2 THREE.Vector2 vec3 THREE.Vector3 or THREE.Color vec4 THREE.Vector4 mat3 (ThreeJS r132+ only) THREE.Matrix3 mat4 (ThreeJS r132+ only) THREE.Matrix4 Resetting to defaults \u00b6 If you have set instance-specific values for a given uniform but you want to revert all those to the single original uniform value, you can call: mesh . unsetUniform ( uniformName ) Examples \u00b6 Instanced spheres with varying metalness/roughness (uses react-three-fiber ) Instanced beziers with varying control points (plain Three.js + BezierMesh )","title":"InstancedUniformsMesh"},{"location":"three-instanced-uniforms-mesh/#instanceduniformsmesh","text":"This package provides a InstancedUniformsMesh class which extends Three.js's InstancedMesh to allow its material's shader uniforms to be set individually per instance. It behaves just like InstancedMesh but exposes a new method: mesh . setUniformAt ( uniformName , instanceIndex , value ) When you call setUniformAt , the geometry and the material's shaders will be automatically upgraded behind the scenes to turn that uniform into an instanced buffer attribute, filling in the other indices with the uniform's default value. You can do this for any uniform of type float , vec2 , vec3 , or vec4 . It works both for built-in Three.js materials and also for any custom ShaderMaterial. For example, here is how you could set random emissive and metalness values for each instance using a MeshStandardMaterial : import { InstancedUniformsMesh } from 'three-instanced-uniforms-mesh' const count = 100 const mesh = new InstancedUniformsMesh ( someGeometry , new MeshStandardMaterial (), count ) const color = new Color () for ( let i = 0 ; i < count ; i ++ ) { mesh . setMatrixAt ( i , someMatrixValue ) mesh . setUniformAt ( 'metalness' , i , Math . random ()) mesh . setUniformAt ( 'emissive' , i , color . set ( Math . random () * 0xffffff )) } While this is obviously useful for Three.js's built in materials, it really shines with custom shaders. Just declare any configurable parameters as uniforms in your custom shader, and then you can use that either on a single non-instanced Mesh by setting the material's uniforms directly, or instance it using InstancedUniformsMesh by calling setUniformAt . Your shader doesn't need to change at all to support the instancing! Note: Calling setUniformAt automatically marks the underlying buffer attributes for upload, so unlike setMatrixAt or setColorAt you don't need to set needsUpdate manually.","title":"InstancedUniformsMesh"},{"location":"three-instanced-uniforms-mesh/#value-types","text":"The type of the value argument should match the type of the uniform defined in the material's shader: For a uniform of type: Pass a value of this type: float Number vec2 THREE.Vector2 vec3 THREE.Vector3 or THREE.Color vec4 THREE.Vector4 mat3 (ThreeJS r132+ only) THREE.Matrix3 mat4 (ThreeJS r132+ only) THREE.Matrix4","title":"Value Types"},{"location":"three-instanced-uniforms-mesh/#resetting-to-defaults","text":"If you have set instance-specific values for a given uniform but you want to revert all those to the single original uniform value, you can call: mesh . unsetUniform ( uniformName )","title":"Resetting to defaults"},{"location":"three-instanced-uniforms-mesh/#examples","text":"Instanced spheres with varying metalness/roughness (uses react-three-fiber ) Instanced beziers with varying control points (plain Three.js + BezierMesh )","title":"Examples"},{"location":"troika-2d/","text":"Documentation to come...","title":"Troika 2D - Overview"},{"location":"troika-2d/html-overlays/","text":"Documentation to come...","title":"HTML Overlays"},{"location":"troika-2d/objects/","text":"Documentation to come...","title":"Interactivity in 2D"},{"location":"troika-3d/","text":"The troika-3d package provides the ability to create interactive 3D scenes with Troika's declarative framework. It uses Three.js as its underlying WebGL renderer, giving you access to Three's full set of tools and its excellent community. It does very little to abstract away from Three's API, and you will need to know the Three.js object model well to use it. But through its primary facade class, Object3DFacade , it gives you a straightforward way to: componentize your 3D objects manage them all together declaratively apply automatic transitions and animations make them interactive with pointer events optimize for the best frame rate Installation \u00b6 npm install troika-3d You will also need to install a compatible version of Three.js . See the Setup page for details about Three.js versions. npm install three Next Steps \u00b6 If you haven't already, you should familiarize yourself with the Troika framework's Core Concepts . Troika 3D builds on those. Then, move on to Creating a 3D Scene and Adding 3D Objects to it.","title":"Troika 3D - Overview"},{"location":"troika-3d/#installation","text":"npm install troika-3d You will also need to install a compatible version of Three.js . See the Setup page for details about Three.js versions. npm install three","title":"Installation"},{"location":"troika-3d/#next-steps","text":"If you haven't already, you should familiarize yourself with the Troika framework's Core Concepts . Troika 3D builds on those. Then, move on to Creating a 3D Scene and Adding 3D Objects to it.","title":"Next Steps"},{"location":"troika-3d/html-overlays/","text":"Documentation to come...","title":"HTML Overlays"},{"location":"troika-3d/instancing/","text":"Troika's instancing abstraction is super powerful. Documentation to come...","title":"GPU Instancing"},{"location":"troika-3d/interactivity-and-events/","text":"Objects in 3D scenes inherit all the useful event handling features from Troika Core's event system. See the core Interactivity and Events documentation for what it can do. Troika 3D also adds some enhancements, which are described here: Raycasting \u00b6 Any Object3DFacade with a pointer-related event listener, a pointerStates property, or pointerEvents:true will be raycasted in the scene and, if that raycast intersects, will dispatch a corresponding event like \"mouseover\", which bubbles up the facade tree. The event object that is dispatched will always have a ray property holding a Three.js Ray , which will be set from the mouse position on screens, or from a pointer ray in WebXR , etc. as appropriate. Because the event can come from different sources, it's safer for handler code to rely on that ray rather than trying to use e.clientX etc. The raycasting process is highly optimized behind the scenes using an octree prefilter. See the performance doc for details.","title":"Interactivity and Events in 3D"},{"location":"troika-3d/interactivity-and-events/#raycasting","text":"Any Object3DFacade with a pointer-related event listener, a pointerStates property, or pointerEvents:true will be raycasted in the scene and, if that raycast intersects, will dispatch a corresponding event like \"mouseover\", which bubbles up the facade tree. The event object that is dispatched will always have a ray property holding a Three.js Ray , which will be set from the mouse position on screens, or from a pointer ray in WebXR , etc. as appropriate. Because the event can come from different sources, it's safer for handler code to rely on that ray rather than trying to use e.clientX etc. The raycasting process is highly optimized behind the scenes using an octree prefilter. See the performance doc for details.","title":"Raycasting"},{"location":"troika-3d/objects/","text":"So you've got a 3D scene with a camera and now you want to add some 3D objects to it, naturally! Like every other object in Troika, 3D object types are defined by Facades , and configured by scene descriptors . To help you out, The troika-3d package provides some Facade types that know how to manage and optimize a tree of Three.js objects. They all use Object3DFacade as their foundation: Object3DFacade \u00b6 Any Three.js Object3D in your scene will, naturally, be represented by an Object3DFacade . This is a specialized Facade base class which knows some things about dealing with Object3D , such as: Properties for positioning/rotation/scaling, with automatic optimized matrix updates Raycasting methods, with related optimizations Methods for querying world positions, camera position, etc. Various shortcut passthrough properties This is just a base class, so in most cases it will be more convenient for you to use a MeshFacade or a Group3DFacade , but all the properties and methods described here will apply to those as well. Construction \u00b6 Every concrete subclass of Object3DFacade must create a Three.js Object3D instance (a Mesh , Line , Group , etc.) that will become the backing implementation for that facade. It will be stored as this.threeObject for use later on, and will be guaranteed to never change during the lifetime of the facade instance. This strict contract makes it easier to reason about in other logic, and allows Troika to apply certain optimizations it couldn't otherwise. To create the Object3D , you can either: 1) Implement the initThreeObject() method and return the Object3D instance, or 2) Override the constructor and pass the Object3D as a second argument to super(parent, obj3D) Generally the first method is preferred, though if you're already overriding the constructor for other purposes then the second method can be easier. An example using initThreeObject() : import { Object3DFacade } from 'troika-3d' import { Mesh , BoxBufferGeometry , MeshStandardMaterial } from 'three' // It's often to define a singleton geometry instance that can be used // across all instances of this object type: const geometry = new BoxBufferGeometry () class MyObject extends Object3DFacade { initThreeObject () { return new Mesh ( geometry , new MeshStandardMaterial ()) } afterUpdate () { // The Mesh created above can be referenced as `threeObject`: this . threeObject . material . color . set ( this . color ) super . afterUpdate () } } Or an example constructor override: //... class MyObject extends Object3DFacade { constructor ( parent ) { const threeObj = new Mesh ( geometry , new MeshStandardMaterial ()) super ( parent , threeObj ) } // ... } Properties \u00b6 The following properties are supported by all Object3DFacade subclasses: threeObject - This is a reference to the Three.js Object3D instance that was created in the initThreeObject method or the constructor. This will be a stable reference, never changing during the facade instance's lifetime. It will be deleted upon destruction, however. parent - This is a reference to the parent Facade instance. This will be a stable reference, never changing during the facade instance's lifetime. It will be deleted upon destruction, however. To access the nearest parent Object3D , use this.threeObject.parent instead. castShadow , receiveShadow - Shortcuts to setting these shadow-related properties on the threeObject. renderOrder - Shortcut to the renderOrder property on the threeObject. visible - Shortcut to the visible property on the threeObject. raycastSide - Lets you force a different side than that of the material during mesh raycasting. Should be set to FrontSide | BackSide | DoubleSide , or null to use the material's side . Local Transform Properties \u00b6 These properties expose the Three object's position , scale , quaternion , and rotation objects' values. They are synced to those objects, but exposing them as flat Facade properties makes it easy to animate them and to track their changes for optimized matrix updating. x , y , z - These set the object's position transform in local space. scale , scaleX , scaleY , scaleZ - These set the object's scale transform in local space. The scale shortcut sets all the directional scales to the same value. rotateX , rotateY , rotateZ , rotateOrder - These set the object's Euler rotation transform in local space. quaternionX , quaternionY , quaternionZ , quaternionW - These set the object's Quaternion rotation transform in local space. Methods \u00b6 getWorldPosition(Vector3?) - Gets the world position of this object's origin. If a Vector3 is passed, the position will be written into that object, otherwise it will return a new Vector3. Assuming this is called in the facade's update phase , the world matrix will be up-to-date. getProjectedPosition(x, y, z) - Given x/y/z coordinates in local space, calculates the projected view space coordinates. Returns a Vector3 where x and y are the view position in screen pixels, and z is the worldspace distance from the camera. getCameraPosition(Vector3?) - Gets the current world position of the camera. If a Vector3 is passed, the position will be written into that object, otherwise it will return a new Vector3. getCameraDistance() - Returns the current distance in world units between this object's origin and the camera. getCameraFacade() - Returns a reference to the CameraFacade instance. This can be used to access low-level info about the camera such as its various matrices and projection attributes, but be careful not to make modifications to the camera as that can lead to things getting out of sync. getSceneFacade() - Returns a reference to the SceneFacade instance. This can be useful in a pinch, but it's usually better to pass any required scene-level values to each facade. updateMatrices() - Updates the underlying threeObject's matrix and matrixWorld to the current state of this object's transform and those of its ancestors, if necessary. This bypasses the updateMatrix and updateMatrixWorld methods of the Three.js objects with a more efficient approach that doesn't require traversing the entire tree prior to every render. As long as this is called from the afterUpdate lifecycle method or later, it can be safely assumed that the world matrices of all ancestors have already been similarly updated, so the result should always be accurate. markWorldMatrixDirty() - If the threeObject.matrixWorld is modified manually instead of via the local transform properties , as is sometimes required for more complex transformations, you should call this to update the internal caches and signal that child objects should update their own matrices to match. MeshFacade \u00b6 You will likely most often want to use MeshFacade instead of creating your own Object3DFacade subclass. This prevents you from having to implement your own constructor override, creating a Mesh instance automatically, and adds some additional helpful facade properties for you. Properties \u00b6 geometry - Lets you set the mesh's geometry . You'll usually only do this once, but you can also change it on the fly, e.g. for choosing an LOD based on camera distance. material - Lets you change the mesh's material . In addition to accepting Three.js Material instances, it also supports the following string aliases for common built-in Three.js materials: \"basic\", \"depth\", \"distance\", \"lambert\", \"matcap\", \"normal\", \"phong\", \"physical\", \"standard\", and \"toon\". Defaults to \"standard\" for creating a MeshStandardMaterial . material.xyz - For all of the above built-in material types, MeshFacade automatically creates setters for the properties of those materials. For example in a scene descriptor object: { facade : MeshFacade , //... material : 'standard' , 'material.color' : 0x3366cc , 'material.metalness' : 0.8 , 'material.roughness' : 0.5 } Notice how you must include quotes around the material properties since they include dots in them. autoDisposeGeometry - If set to true , the geometry's dispose method will automatically be called when the facade is destroyed, and when swapping it out with another geometry. This can be useful for freeing resources for large geometries that only appear once, but can hurt performance if there are multiple instances of that geometry in the scene or if it is removed and re-added later. In many cases, especially for simpler geometries, it's better to avoid disposal; therefore this defaults to false . autoDisposeMaterial - If set to true , the material's dispose method will automatically be called when the facade is destroyed, and when swapping it out with another material. This is almost never needed, so it defaults to false . If your material uses a Texture that needs to be disposed, you will need to do that yourself, e.g. in a subclass that overrides the destructor method. Group3DFacade \u00b6 This is a specialized Object3DFacade for Three.js Group objects. It's basically just an Object3DFacade that already creates a Group object in its constructor, though it also applies some additional optimizations. You can use it directly in scene descriptors, with any child objects as its children : import { Group3DFacade } from 'troika-3d' //...descriptor in scene: { facade : Group3DFacade , z : - 1 , scale : 0.5 , children : [ { facade : DonutFacade , x : - 1 }, { facade : PyramidFacade , x : 1 } ] } It can also be useful to extend a custom Facade class from Group3DFacade , for example to implement some controller logic or to manage a collection of rendered objects as a single component. class GaugeFacade extends Group3DFacade { /** @type number - from 0 to 100 */ value = 0 describeChildren () { return [ { key : 'ring' , facade : GaugeRing , //another custom facade percent : this . value , color : valueToColor ( this . value ), radius : 0.1 , transition : { percent : true } //animate ring changes }, { key : 'label' , facade : Text3DFacade , //see troika-3d-text package anchorX : 'center' , anchorY : 'middle' , fontSize : 0.05 , text : ` ${ this . value } %` } ] } } Also, since pointer events bubble , you can add listeners on a Group3DFacade to respond to raycasting events on any of its descendant objects. Just remember that you may need to set pointerEvents: true on those objects to trigger raycasting for them. Instanceable3DFacade \u00b6 This is a special kind of Object3DFacade that renders its underlying object using GPU instancing along with all other Instanceable3DFacade instances of the same type, but behaves as its own component instance in terms of how it's configured and handles events. See the page on instancing for details.","title":"Adding 3D Objects"},{"location":"troika-3d/objects/#object3dfacade","text":"Any Three.js Object3D in your scene will, naturally, be represented by an Object3DFacade . This is a specialized Facade base class which knows some things about dealing with Object3D , such as: Properties for positioning/rotation/scaling, with automatic optimized matrix updates Raycasting methods, with related optimizations Methods for querying world positions, camera position, etc. Various shortcut passthrough properties This is just a base class, so in most cases it will be more convenient for you to use a MeshFacade or a Group3DFacade , but all the properties and methods described here will apply to those as well.","title":"Object3DFacade"},{"location":"troika-3d/objects/#construction","text":"Every concrete subclass of Object3DFacade must create a Three.js Object3D instance (a Mesh , Line , Group , etc.) that will become the backing implementation for that facade. It will be stored as this.threeObject for use later on, and will be guaranteed to never change during the lifetime of the facade instance. This strict contract makes it easier to reason about in other logic, and allows Troika to apply certain optimizations it couldn't otherwise. To create the Object3D , you can either: 1) Implement the initThreeObject() method and return the Object3D instance, or 2) Override the constructor and pass the Object3D as a second argument to super(parent, obj3D) Generally the first method is preferred, though if you're already overriding the constructor for other purposes then the second method can be easier. An example using initThreeObject() : import { Object3DFacade } from 'troika-3d' import { Mesh , BoxBufferGeometry , MeshStandardMaterial } from 'three' // It's often to define a singleton geometry instance that can be used // across all instances of this object type: const geometry = new BoxBufferGeometry () class MyObject extends Object3DFacade { initThreeObject () { return new Mesh ( geometry , new MeshStandardMaterial ()) } afterUpdate () { // The Mesh created above can be referenced as `threeObject`: this . threeObject . material . color . set ( this . color ) super . afterUpdate () } } Or an example constructor override: //... class MyObject extends Object3DFacade { constructor ( parent ) { const threeObj = new Mesh ( geometry , new MeshStandardMaterial ()) super ( parent , threeObj ) } // ... }","title":"Construction"},{"location":"troika-3d/objects/#properties","text":"The following properties are supported by all Object3DFacade subclasses: threeObject - This is a reference to the Three.js Object3D instance that was created in the initThreeObject method or the constructor. This will be a stable reference, never changing during the facade instance's lifetime. It will be deleted upon destruction, however. parent - This is a reference to the parent Facade instance. This will be a stable reference, never changing during the facade instance's lifetime. It will be deleted upon destruction, however. To access the nearest parent Object3D , use this.threeObject.parent instead. castShadow , receiveShadow - Shortcuts to setting these shadow-related properties on the threeObject. renderOrder - Shortcut to the renderOrder property on the threeObject. visible - Shortcut to the visible property on the threeObject. raycastSide - Lets you force a different side than that of the material during mesh raycasting. Should be set to FrontSide | BackSide | DoubleSide , or null to use the material's side .","title":"Properties"},{"location":"troika-3d/objects/#local-transform-properties","text":"These properties expose the Three object's position , scale , quaternion , and rotation objects' values. They are synced to those objects, but exposing them as flat Facade properties makes it easy to animate them and to track their changes for optimized matrix updating. x , y , z - These set the object's position transform in local space. scale , scaleX , scaleY , scaleZ - These set the object's scale transform in local space. The scale shortcut sets all the directional scales to the same value. rotateX , rotateY , rotateZ , rotateOrder - These set the object's Euler rotation transform in local space. quaternionX , quaternionY , quaternionZ , quaternionW - These set the object's Quaternion rotation transform in local space.","title":"Local Transform Properties"},{"location":"troika-3d/objects/#methods","text":"getWorldPosition(Vector3?) - Gets the world position of this object's origin. If a Vector3 is passed, the position will be written into that object, otherwise it will return a new Vector3. Assuming this is called in the facade's update phase , the world matrix will be up-to-date. getProjectedPosition(x, y, z) - Given x/y/z coordinates in local space, calculates the projected view space coordinates. Returns a Vector3 where x and y are the view position in screen pixels, and z is the worldspace distance from the camera. getCameraPosition(Vector3?) - Gets the current world position of the camera. If a Vector3 is passed, the position will be written into that object, otherwise it will return a new Vector3. getCameraDistance() - Returns the current distance in world units between this object's origin and the camera. getCameraFacade() - Returns a reference to the CameraFacade instance. This can be used to access low-level info about the camera such as its various matrices and projection attributes, but be careful not to make modifications to the camera as that can lead to things getting out of sync. getSceneFacade() - Returns a reference to the SceneFacade instance. This can be useful in a pinch, but it's usually better to pass any required scene-level values to each facade. updateMatrices() - Updates the underlying threeObject's matrix and matrixWorld to the current state of this object's transform and those of its ancestors, if necessary. This bypasses the updateMatrix and updateMatrixWorld methods of the Three.js objects with a more efficient approach that doesn't require traversing the entire tree prior to every render. As long as this is called from the afterUpdate lifecycle method or later, it can be safely assumed that the world matrices of all ancestors have already been similarly updated, so the result should always be accurate. markWorldMatrixDirty() - If the threeObject.matrixWorld is modified manually instead of via the local transform properties , as is sometimes required for more complex transformations, you should call this to update the internal caches and signal that child objects should update their own matrices to match.","title":"Methods"},{"location":"troika-3d/objects/#meshfacade","text":"You will likely most often want to use MeshFacade instead of creating your own Object3DFacade subclass. This prevents you from having to implement your own constructor override, creating a Mesh instance automatically, and adds some additional helpful facade properties for you.","title":"MeshFacade"},{"location":"troika-3d/objects/#properties_1","text":"geometry - Lets you set the mesh's geometry . You'll usually only do this once, but you can also change it on the fly, e.g. for choosing an LOD based on camera distance. material - Lets you change the mesh's material . In addition to accepting Three.js Material instances, it also supports the following string aliases for common built-in Three.js materials: \"basic\", \"depth\", \"distance\", \"lambert\", \"matcap\", \"normal\", \"phong\", \"physical\", \"standard\", and \"toon\". Defaults to \"standard\" for creating a MeshStandardMaterial . material.xyz - For all of the above built-in material types, MeshFacade automatically creates setters for the properties of those materials. For example in a scene descriptor object: { facade : MeshFacade , //... material : 'standard' , 'material.color' : 0x3366cc , 'material.metalness' : 0.8 , 'material.roughness' : 0.5 } Notice how you must include quotes around the material properties since they include dots in them. autoDisposeGeometry - If set to true , the geometry's dispose method will automatically be called when the facade is destroyed, and when swapping it out with another geometry. This can be useful for freeing resources for large geometries that only appear once, but can hurt performance if there are multiple instances of that geometry in the scene or if it is removed and re-added later. In many cases, especially for simpler geometries, it's better to avoid disposal; therefore this defaults to false . autoDisposeMaterial - If set to true , the material's dispose method will automatically be called when the facade is destroyed, and when swapping it out with another material. This is almost never needed, so it defaults to false . If your material uses a Texture that needs to be disposed, you will need to do that yourself, e.g. in a subclass that overrides the destructor method.","title":"Properties"},{"location":"troika-3d/objects/#group3dfacade","text":"This is a specialized Object3DFacade for Three.js Group objects. It's basically just an Object3DFacade that already creates a Group object in its constructor, though it also applies some additional optimizations. You can use it directly in scene descriptors, with any child objects as its children : import { Group3DFacade } from 'troika-3d' //...descriptor in scene: { facade : Group3DFacade , z : - 1 , scale : 0.5 , children : [ { facade : DonutFacade , x : - 1 }, { facade : PyramidFacade , x : 1 } ] } It can also be useful to extend a custom Facade class from Group3DFacade , for example to implement some controller logic or to manage a collection of rendered objects as a single component. class GaugeFacade extends Group3DFacade { /** @type number - from 0 to 100 */ value = 0 describeChildren () { return [ { key : 'ring' , facade : GaugeRing , //another custom facade percent : this . value , color : valueToColor ( this . value ), radius : 0.1 , transition : { percent : true } //animate ring changes }, { key : 'label' , facade : Text3DFacade , //see troika-3d-text package anchorX : 'center' , anchorY : 'middle' , fontSize : 0.05 , text : ` ${ this . value } %` } ] } } Also, since pointer events bubble , you can add listeners on a Group3DFacade to respond to raycasting events on any of its descendant objects. Just remember that you may need to set pointerEvents: true on those objects to trigger raycasting for them.","title":"Group3DFacade"},{"location":"troika-3d/objects/#instanceable3dfacade","text":"This is a special kind of Object3DFacade that renders its underlying object using GPU instancing along with all other Instanceable3DFacade instances of the same type, but behaves as its own component instance in terms of how it's configured and handles events. See the page on instancing for details.","title":"Instanceable3DFacade"},{"location":"troika-3d/performance/","text":"Compared to raw Three.js, Troika automatically performs several optimizations to reduce the CPU time spent on each render frame. Here are the most impactful: Unnecessary renders \u00b6 The typical setup for Three.js rendering involves an animation loop that recursively calls requestAnimationFrame and re-renders the entire scene on every frame, regardless of whether anything in the scene has actually changed. This causes unnecessarily high CPU/GPU usage and battery drain for scenes that are largely static. Troika controls when the Three.js scene is re-rendered, only doing so when: The scene is updated A facade animation or transition is running A facade changes properties due to pointerStates interactions A facade indicates that it requires a re-render by calling its requestRender method Matrix calculations \u00b6 By default, Three.js takes a brute-force approach to calculating the world matrices of objects: on every frame it traverses the entire scene graph and for each Object3D it both composes a local transform matrix and multiplies it with the parent to get its worldMatrix . This can quickly add up to be the primary CPU user in large scenes, even if no objects are moving. The Object3D.matrixAutoUpdate and Scene.autoUpdate flags do allow you to limit the brute-force matrix calculations, but then performing those updates manually (a tedious and error-prone process) becomes the author's responsibility. Troika gives you the best of both worlds by automatically setting scene.autoUpdate=false and threeObject.matrixAutoUpdate=false for every object it manages, and then taking care of recalculating the local and/or world matrices only when necessary. More specifically: The local matrix is only recomposed when one of the properties that may affect it ( x / y / z / rotateX|Y|Z / scaleX|Y|Z ) changes. The worldMatrix is only remultiplied when the local matrix or the worldMatrix of its parent have changed. This results in the time taken by matrix calculations dropping to nearly zero when objects are not moving, even for very large scenes. NOTE: This is perhaps the single most valuable optimization Troika performs. Not only does it nearly remove the per-frame matrix update cost, but knowing exactly when any object's matrix is changed opens up the possibility for other optimizations like maintaining a raycasting octree and more flexible GPU instancing abstractions. It is our goal to attempt extracting this matrix management capability from Troika's framework code, allowing it to be used in any Three.js scene, even if managed by another framework. Raycasting \u00b6 The standard method for picking 3D objects with a pointer (mouse/touch/etc.) is to determine a ray for that pointer and then search the scene's objects for those that intersect that ray, also known as \"raycasting.\" Three.js provides a Raycaster class for that purpose; however the usual approach is to iterate through all the objects in the scene and calculate the ray intersection for each. For scenes with many objects this can quickly add up and produce frame drops while raycasting. Troika optimizes this process by maintaining an internal Octree of the bounding spheres for every object in the scene, and then using that as a fast pre-filter to skip ray intersection calculations for objects that have no possibility of matching. TODO: note about how to specify bounding sphere for use in the octree when using custom shaders that manipulate the vertices Scene graph traversal \u00b6 On every render frame Three.js traverses the entire scene graph, deciding what to do with each type of object in the tree, if anything. This means it does several type checks for every object, even those that have no visible representation in the scene, such as empty Group s or the invisible objects used for tracking HTML Overlay positions. To help with this, Troika performs the following optimizations for those objects it manages which it knows have no visible rendering: It sets threeObject.layers.mask = 0 , which makes the renderer skip its per-frame type checks. If the object has no children, it is not added to the Three.js scene graph at all. Authors may also set the custom property threeObject.isRenderable = false to gain these same optimizations for their own invisible objects. The proeprty must be set prior to passing the object to the Object3DFacade 's constructor. Batch object removal \u00b6 Removing large numbers of scene objects from their parents can be slow in Three.js due to how it splices the parent's children array for each object removed. Troika batches the removal of many children into a single operation to speed this up.","title":"Performance Optimization"},{"location":"troika-3d/performance/#unnecessary-renders","text":"The typical setup for Three.js rendering involves an animation loop that recursively calls requestAnimationFrame and re-renders the entire scene on every frame, regardless of whether anything in the scene has actually changed. This causes unnecessarily high CPU/GPU usage and battery drain for scenes that are largely static. Troika controls when the Three.js scene is re-rendered, only doing so when: The scene is updated A facade animation or transition is running A facade changes properties due to pointerStates interactions A facade indicates that it requires a re-render by calling its requestRender method","title":"Unnecessary renders"},{"location":"troika-3d/performance/#matrix-calculations","text":"By default, Three.js takes a brute-force approach to calculating the world matrices of objects: on every frame it traverses the entire scene graph and for each Object3D it both composes a local transform matrix and multiplies it with the parent to get its worldMatrix . This can quickly add up to be the primary CPU user in large scenes, even if no objects are moving. The Object3D.matrixAutoUpdate and Scene.autoUpdate flags do allow you to limit the brute-force matrix calculations, but then performing those updates manually (a tedious and error-prone process) becomes the author's responsibility. Troika gives you the best of both worlds by automatically setting scene.autoUpdate=false and threeObject.matrixAutoUpdate=false for every object it manages, and then taking care of recalculating the local and/or world matrices only when necessary. More specifically: The local matrix is only recomposed when one of the properties that may affect it ( x / y / z / rotateX|Y|Z / scaleX|Y|Z ) changes. The worldMatrix is only remultiplied when the local matrix or the worldMatrix of its parent have changed. This results in the time taken by matrix calculations dropping to nearly zero when objects are not moving, even for very large scenes. NOTE: This is perhaps the single most valuable optimization Troika performs. Not only does it nearly remove the per-frame matrix update cost, but knowing exactly when any object's matrix is changed opens up the possibility for other optimizations like maintaining a raycasting octree and more flexible GPU instancing abstractions. It is our goal to attempt extracting this matrix management capability from Troika's framework code, allowing it to be used in any Three.js scene, even if managed by another framework.","title":"Matrix calculations"},{"location":"troika-3d/performance/#raycasting","text":"The standard method for picking 3D objects with a pointer (mouse/touch/etc.) is to determine a ray for that pointer and then search the scene's objects for those that intersect that ray, also known as \"raycasting.\" Three.js provides a Raycaster class for that purpose; however the usual approach is to iterate through all the objects in the scene and calculate the ray intersection for each. For scenes with many objects this can quickly add up and produce frame drops while raycasting. Troika optimizes this process by maintaining an internal Octree of the bounding spheres for every object in the scene, and then using that as a fast pre-filter to skip ray intersection calculations for objects that have no possibility of matching. TODO: note about how to specify bounding sphere for use in the octree when using custom shaders that manipulate the vertices","title":"Raycasting"},{"location":"troika-3d/performance/#scene-graph-traversal","text":"On every render frame Three.js traverses the entire scene graph, deciding what to do with each type of object in the tree, if anything. This means it does several type checks for every object, even those that have no visible representation in the scene, such as empty Group s or the invisible objects used for tracking HTML Overlay positions. To help with this, Troika performs the following optimizations for those objects it manages which it knows have no visible rendering: It sets threeObject.layers.mask = 0 , which makes the renderer skip its per-frame type checks. If the object has no children, it is not added to the Three.js scene graph at all. Authors may also set the custom property threeObject.isRenderable = false to gain these same optimizations for their own invisible objects. The proeprty must be set prior to passing the object to the Object3DFacade 's constructor.","title":"Scene graph traversal"},{"location":"troika-3d/performance/#batch-object-removal","text":"Removing large numbers of scene objects from their parents can be slow in Three.js due to how it splices the parent's children array for each object removed. Troika batches the removal of many children into a single operation to speed this up.","title":"Batch object removal"},{"location":"troika-3d/scenes/","text":"So you want to create a 3D scene! Let's go. Note: Currently the only entry point provided is a React component called <Canvas3D> . This assumes your application uses React, and you're adding a Troika 3D canvas into it. In the future we plan to provide entry points for other frameworks, a web component, and a pure JS entry point function. Contributions are welcome. Canvas3D \u00b6 The <Canvas3D> React component is your starting point. This component creates a WebGL canvas and other required DOM elements, takes configuration props for the Three.js renderer, and accepts descriptors for a camera, lights, and all your scene's objects. Configuration Props \u00b6 width and height - These are required to set the size of the canvas. If you want to have the canvas expand to the size of its container, then you'll need to use something like useDimensions in your outer React component to measure the available size. antialias - If set, enables antialiasing. background - Sets the Three.js scene's background canvasStyle - An optional object holding CSS style properties to apply to the <canvas> element. Defaults to {width: '100%', height: '100%'} . className - An optional class attribute that will be applied to the wrapper element. Defaults to \"troika\" . continuousRender - If set, frames will be rendered continuously, instead of the default behavior of only rendering when something in the scene requires it. environment - Sets the Three.js scene's environment onBackgroundClick - A function that will be called when the user clicks the scene's background without hitting an object. outputEncoding - Sets the Three.js renderer's outputEncoding pixelRatio - Sets the pixel ratio for the canvas. Defaults to the current screen's reported window.devicePixelRatio . rendererClass - Lets you override the Three.js WebGLRenderer class with a custom subclass of your own. stats - If set, statistics about the frame rate and number of things rendered will be displayed. Useful for debugging. toneMapping - Sets the Three.js renderer's toneMapping worldFacade - Lets you override the World3DFacade class used as the main world controller with a custom subclass of your own. worldProps - An object holding properties that will be copied onto the worldFacade . Scene Structure Props \u00b6 lights \u00b6 This should be set to an array of descriptor objects describing the main lights in your scene. You can choose the type of light with the type property and one of the following strings: \"ambient\", \"directional\", \"spot\", \"point\", or \"hemisphere\". You can also set the facade property to use a custom facade wrapper. lights = {[ { type : 'ambient' , color : 0x999999 }, { type : 'directional' , x : 1 , y : 1 , z : 1 }, { facade : WanderingPointLight , color : 0xff0000 } ]} camera \u00b6 This should be set to a descriptor object describing the type of camera, its projection parameters, position, etc. It defaults to a PerspectiveCamera3DFacade with aspect ratio based on the canvas's dimensions. camera = {{ x : 5 , rotateY : - Math . PI / 2 , fov : 75 , far : 30 }} import { OrthographicCamera3DFacade } from 'troika-3d' //... camera = {{ facade : OrthographicCamera3DFacade , z : 1 , top : height / 2 , bottom : - height / 2 , left : 0 , right : width }} camera = {{ facade : OrbitingCameraFacade //a custom facade with orbiting movement }} Since this camera config is a descriptor object , it can also be given animations and transitions . camera = {{ x : currentPos . x , z : currentPos . z , rotateY : currentPos . angle , // Smoothly transition between positions: transition : { x : true , z : true , rotateY : true }, // Bob in place: animation : { from : { y : 1.4 }, to : { y : 1.5 }, duration : 3000 , direction : 'alternate' , iterations : Infinity } }} objects \u00b6 This is an array of descriptor objects describing all the things in your scene. See the page on Adding 3D Objects for details. objects = {[ { key : 'mainGroup' , z : - 2 , facade : Group3DFacade , children : [ { facade : SphereFacade , radius : 0.25 , x : - 1 , 'material.color' : 0x3366cc }, { facade : CustomObjectFacade , x : 1 } ] } ]} fog \u00b6 This is an object holding config properties for a Three.js Fog or FogExp2 . It is not a proper Troika descriptor; if it has a density property it will create a FogExp2 otherwise it will create a Fog .","title":"Creating a 3D Scene"},{"location":"troika-3d/scenes/#canvas3d","text":"The <Canvas3D> React component is your starting point. This component creates a WebGL canvas and other required DOM elements, takes configuration props for the Three.js renderer, and accepts descriptors for a camera, lights, and all your scene's objects.","title":"Canvas3D"},{"location":"troika-3d/scenes/#configuration-props","text":"width and height - These are required to set the size of the canvas. If you want to have the canvas expand to the size of its container, then you'll need to use something like useDimensions in your outer React component to measure the available size. antialias - If set, enables antialiasing. background - Sets the Three.js scene's background canvasStyle - An optional object holding CSS style properties to apply to the <canvas> element. Defaults to {width: '100%', height: '100%'} . className - An optional class attribute that will be applied to the wrapper element. Defaults to \"troika\" . continuousRender - If set, frames will be rendered continuously, instead of the default behavior of only rendering when something in the scene requires it. environment - Sets the Three.js scene's environment onBackgroundClick - A function that will be called when the user clicks the scene's background without hitting an object. outputEncoding - Sets the Three.js renderer's outputEncoding pixelRatio - Sets the pixel ratio for the canvas. Defaults to the current screen's reported window.devicePixelRatio . rendererClass - Lets you override the Three.js WebGLRenderer class with a custom subclass of your own. stats - If set, statistics about the frame rate and number of things rendered will be displayed. Useful for debugging. toneMapping - Sets the Three.js renderer's toneMapping worldFacade - Lets you override the World3DFacade class used as the main world controller with a custom subclass of your own. worldProps - An object holding properties that will be copied onto the worldFacade .","title":"Configuration Props"},{"location":"troika-3d/scenes/#scene-structure-props","text":"","title":"Scene Structure Props"},{"location":"troika-3d/scenes/#lights","text":"This should be set to an array of descriptor objects describing the main lights in your scene. You can choose the type of light with the type property and one of the following strings: \"ambient\", \"directional\", \"spot\", \"point\", or \"hemisphere\". You can also set the facade property to use a custom facade wrapper. lights = {[ { type : 'ambient' , color : 0x999999 }, { type : 'directional' , x : 1 , y : 1 , z : 1 }, { facade : WanderingPointLight , color : 0xff0000 } ]}","title":"lights"},{"location":"troika-3d/scenes/#camera","text":"This should be set to a descriptor object describing the type of camera, its projection parameters, position, etc. It defaults to a PerspectiveCamera3DFacade with aspect ratio based on the canvas's dimensions. camera = {{ x : 5 , rotateY : - Math . PI / 2 , fov : 75 , far : 30 }} import { OrthographicCamera3DFacade } from 'troika-3d' //... camera = {{ facade : OrthographicCamera3DFacade , z : 1 , top : height / 2 , bottom : - height / 2 , left : 0 , right : width }} camera = {{ facade : OrbitingCameraFacade //a custom facade with orbiting movement }} Since this camera config is a descriptor object , it can also be given animations and transitions . camera = {{ x : currentPos . x , z : currentPos . z , rotateY : currentPos . angle , // Smoothly transition between positions: transition : { x : true , z : true , rotateY : true }, // Bob in place: animation : { from : { y : 1.4 }, to : { y : 1.5 }, duration : 3000 , direction : 'alternate' , iterations : Infinity } }}","title":"camera"},{"location":"troika-3d/scenes/#objects","text":"This is an array of descriptor objects describing all the things in your scene. See the page on Adding 3D Objects for details. objects = {[ { key : 'mainGroup' , z : - 2 , facade : Group3DFacade , children : [ { facade : SphereFacade , radius : 0.25 , x : - 1 , 'material.color' : 0x3366cc }, { facade : CustomObjectFacade , x : 1 } ] } ]}","title":"objects"},{"location":"troika-3d/scenes/#fog","text":"This is an object holding config properties for a Three.js Fog or FogExp2 . It is not a proper Troika descriptor; if it has a density property it will create a FogExp2 otherwise it will create a Fog .","title":"fog"},{"location":"troika-3d/text/","text":"The troika-3d-text package provides a Text3DFacade for high quality text rendering in Troika 3D scenes, using signed distance fields (SDF) and antialiasing using standard derivatives. The bulk of its implementation has been extracted to the troika-three-text package which allows it to be used in any Three.js project without any Troika framework dependencies. For the most part Text3DFacade is a passthrough to a Text object from that package. See the troika-three-text docs for the available properties, all of which can be set on Text3DFacade . import { Text3DFacade } from 'troika-3d-text' { key : 'text' , facade : Text3DFacade , font : 'https://url/of/font.woff' , text : 'Hello World!' , fontSize : 0.1 , color : 0xccccff //...other props } This text rendering engine is also used by the troika-3d-ui package to perform text layout measurements for flexbox layout as well as the final rendering.","title":"3D Text"},{"location":"troika-3d-ui/","text":"The troika-3d-ui package allows creating flexbox user interfaces in 3D scenes. It behaves largely like CSS flexbox , but renders in WebGL so it can make use of Three.js materials, can include fully 3D objects within its layout, and remains functional in WebXR. It uses the text layout engine from troika-3d-text , so the flexbox layout can auto-size elements based on the size of their text content, and the final rendering includes high quality antialiased text. Examples: Example 1 Example 2 More documentation to come.","title":"3D User Interfaces"},{"location":"troika-core/animations-and-transitions/","text":"Troika has built-in support for declarative transitions and animations on the properties of any Facade, controlled via transition and animation properties in the scene descriptors . These generally work very much like CSS transitions and CSS animations , so they should be very familiar to web developers. Note: These transitions and animations are driven by the troika-animation package . Facade classes are automatically extended to intercept property changes and apply transitions when needed. Transitions \u00b6 Any descriptor can be given a transition property to automatically intercept changes to certain properties and animate from their previous values to their new values. The transition property should be an object with transitionable property names as keys, and transition specs as values. Those specs can either be objects describing the transition parameters, or true for a default transition. Troika supports both traditional duration-based transitions, like CSS, but also supports \"spring\" animations ala react-spring . Spring animations can often give a more natural feel and behave better when target values change repeatedly during transition, but duration-based transitions can be more predictable. Use the approach that fits your case. A basic example of a descriptor object that defines transitions for its x , y , and z properties: { facade : MyObject , x : xVal , y : yVal , z : zVal , transition : { x : true , // uses a default duration-based transition y : 'spring' , //uses a default spring-based transition z : { //detailed transition parameters: duration : 500 , easing : 'easeOutExpo' } } } When this descriptor is next applied with new values for x , y , and z , those values will be individually transitioned based on their configured parameters. That simple! The custom transition config object can take one of two forms for duration- vs. spring-based animations: Duration-based \u00b6 transition : { z : { duration : 1234 , //in ms, defaults to 750 easing : 'easeInOutBounce' , //easing function, defaults to 'easeOutCubic' delay : 123 , //in ms, defaults to 0 interpolate : 'number' //see \"Interpolation\" below } } Spring-based \u00b6 transition : { myProp : { spring : true , // or spring: 'wobbly', // or spring: {mass, tension, friction}, delay : 250 //in ms, defaults to 0 } } The meanings of the spring configuration parameters, and the named presets, match those from react-spring . Note: Spring-based transitions do not currently support custom interpolations so they should only be used for numeric values. Animations \u00b6 Any descriptor can be given an animation property to define one or more keyframe animations for certain properties. Any animations will start running when the Facade is created and added to the scene. If any aspect of the animation is changed later, the old animation will be stopped and the new one will be started. Here's an example of an animation that will rotate the object indefinitely, looping every 1.5 seconds: { facade : MyObject , animation : { 0 : { rotateY : 0 }, 100 : { rotateY : Math . PI * 2 }, duration : 1500 , iterations : Infinity } } Animation Spec Structure \u00b6 keyframes \u00b6 All animations need at least two keyframes. They are defined by numeric properties from 0 for the first frame to 100 for the last frame, or any number in between. Also the special property names 'from' and 'to' are aliases for 0 and 100 respectively. Each keyframe value is an object holding a set of properties and their target values at that keyframe. The values will be interpolated between the keyframes as the animation runs, applying them to the Facade instance. duration \u00b6 The number of milliseconds over which the animation's keyframes are run. If the animation loops (see iterations ), this is the length of one iteration. delay \u00b6 A number of milliseconds to wait before starting the animation's first frame. easing \u00b6 An easing function for the animation, defaulting to \"linear\". This is applied to the whole animation's progression of keyframes, not individual keyframe segments. iterations \u00b6 The number of times the animation should loop, defaulting to 1 . To loop endlessly, give it the value Infinity . direction \u00b6 Which direction the animation should progress: \"forward\" (the default), \"backward\" , or \"alternate\" to toggle between forward and backward every other iteration. interpolate \u00b6 Defines how non-numeric animated values should be interpolated between keyframes. It takes an object whose keys are property names and values are interpolators . For example: interpolate : { emissive : 'color' } paused \u00b6 If true , the animation will be paused at its current keyframe. This can be toggled on and off to pause and unpause the animation. Exit Animations \u00b6 Since they start when a Facade instance \"enters\" the scene, it's often convenient to think of animation as defining \"entrance animations.\" Troika also supports \"exit animations\" which are applied when an object is removed from the scene. It will temporarily keep that object present in the scene long enough to run its exit animation, before fully destroying it. This allows you to do things like a nice smooth fade-out, scale-out, or fly-away rather than having objects abruptly disappear. To define an exit animation, simply give the descriptor an exitAnimation property. Its value matches the structure of a regular animation . Interpolation \u00b6 Transitions and animations will by default treat property values as numbers and interpolate their \"tweened\" values numerically. But some certain values, such as colors, require a different interpolation strategy. Troika supports the following named interpolations: \"number\" - simple linear interpolation between two numeric values (the default). \"color\" - interprets the start/end values as RGB colors, and interpolates each color channel independently. The start/end values can be 24-bit integers or any CSS color string value, and the interpolated values will always be returned as 24-bit integers (8 bits red, 8 bits green, 8 bits blue.) If you need a different interpolation, you can provide a custom function. Your function will take three parameters: the start value, the end value, and the progress between them (the output of the easing function) in the range from 0 to 1 . It must return an in-between value of the appropriate type.","title":"Animations and Transitions"},{"location":"troika-core/animations-and-transitions/#transitions","text":"Any descriptor can be given a transition property to automatically intercept changes to certain properties and animate from their previous values to their new values. The transition property should be an object with transitionable property names as keys, and transition specs as values. Those specs can either be objects describing the transition parameters, or true for a default transition. Troika supports both traditional duration-based transitions, like CSS, but also supports \"spring\" animations ala react-spring . Spring animations can often give a more natural feel and behave better when target values change repeatedly during transition, but duration-based transitions can be more predictable. Use the approach that fits your case. A basic example of a descriptor object that defines transitions for its x , y , and z properties: { facade : MyObject , x : xVal , y : yVal , z : zVal , transition : { x : true , // uses a default duration-based transition y : 'spring' , //uses a default spring-based transition z : { //detailed transition parameters: duration : 500 , easing : 'easeOutExpo' } } } When this descriptor is next applied with new values for x , y , and z , those values will be individually transitioned based on their configured parameters. That simple! The custom transition config object can take one of two forms for duration- vs. spring-based animations:","title":"Transitions"},{"location":"troika-core/animations-and-transitions/#duration-based","text":"transition : { z : { duration : 1234 , //in ms, defaults to 750 easing : 'easeInOutBounce' , //easing function, defaults to 'easeOutCubic' delay : 123 , //in ms, defaults to 0 interpolate : 'number' //see \"Interpolation\" below } }","title":"Duration-based"},{"location":"troika-core/animations-and-transitions/#spring-based","text":"transition : { myProp : { spring : true , // or spring: 'wobbly', // or spring: {mass, tension, friction}, delay : 250 //in ms, defaults to 0 } } The meanings of the spring configuration parameters, and the named presets, match those from react-spring . Note: Spring-based transitions do not currently support custom interpolations so they should only be used for numeric values.","title":"Spring-based"},{"location":"troika-core/animations-and-transitions/#animations","text":"Any descriptor can be given an animation property to define one or more keyframe animations for certain properties. Any animations will start running when the Facade is created and added to the scene. If any aspect of the animation is changed later, the old animation will be stopped and the new one will be started. Here's an example of an animation that will rotate the object indefinitely, looping every 1.5 seconds: { facade : MyObject , animation : { 0 : { rotateY : 0 }, 100 : { rotateY : Math . PI * 2 }, duration : 1500 , iterations : Infinity } }","title":"Animations"},{"location":"troika-core/animations-and-transitions/#animation-spec-structure","text":"","title":"Animation Spec Structure"},{"location":"troika-core/animations-and-transitions/#keyframes","text":"All animations need at least two keyframes. They are defined by numeric properties from 0 for the first frame to 100 for the last frame, or any number in between. Also the special property names 'from' and 'to' are aliases for 0 and 100 respectively. Each keyframe value is an object holding a set of properties and their target values at that keyframe. The values will be interpolated between the keyframes as the animation runs, applying them to the Facade instance.","title":"keyframes"},{"location":"troika-core/animations-and-transitions/#duration","text":"The number of milliseconds over which the animation's keyframes are run. If the animation loops (see iterations ), this is the length of one iteration.","title":"duration"},{"location":"troika-core/animations-and-transitions/#delay","text":"A number of milliseconds to wait before starting the animation's first frame.","title":"delay"},{"location":"troika-core/animations-and-transitions/#easing","text":"An easing function for the animation, defaulting to \"linear\". This is applied to the whole animation's progression of keyframes, not individual keyframe segments.","title":"easing"},{"location":"troika-core/animations-and-transitions/#iterations","text":"The number of times the animation should loop, defaulting to 1 . To loop endlessly, give it the value Infinity .","title":"iterations"},{"location":"troika-core/animations-and-transitions/#direction","text":"Which direction the animation should progress: \"forward\" (the default), \"backward\" , or \"alternate\" to toggle between forward and backward every other iteration.","title":"direction"},{"location":"troika-core/animations-and-transitions/#interpolate","text":"Defines how non-numeric animated values should be interpolated between keyframes. It takes an object whose keys are property names and values are interpolators . For example: interpolate : { emissive : 'color' }","title":"interpolate"},{"location":"troika-core/animations-and-transitions/#paused","text":"If true , the animation will be paused at its current keyframe. This can be toggled on and off to pause and unpause the animation.","title":"paused"},{"location":"troika-core/animations-and-transitions/#exit-animations","text":"Since they start when a Facade instance \"enters\" the scene, it's often convenient to think of animation as defining \"entrance animations.\" Troika also supports \"exit animations\" which are applied when an object is removed from the scene. It will temporarily keep that object present in the scene long enough to run its exit animation, before fully destroying it. This allows you to do things like a nice smooth fade-out, scale-out, or fly-away rather than having objects abruptly disappear. To define an exit animation, simply give the descriptor an exitAnimation property. Its value matches the structure of a regular animation .","title":"Exit Animations"},{"location":"troika-core/animations-and-transitions/#interpolation","text":"Transitions and animations will by default treat property values as numbers and interpolate their \"tweened\" values numerically. But some certain values, such as colors, require a different interpolation strategy. Troika supports the following named interpolations: \"number\" - simple linear interpolation between two numeric values (the default). \"color\" - interprets the start/end values as RGB colors, and interpolates each color channel independently. The start/end values can be 24-bit integers or any CSS color string value, and the interpolated values will always be returned as 24-bit integers (8 bits red, 8 bits green, 8 bits blue.) If you need a different interpolation, you can provide a custom function. Your function will take three parameters: the start value, the end value, and the progress between them (the output of the easing function) in the range from 0 to 1 . It must return an in-between value of the appropriate type.","title":"Interpolation"},{"location":"troika-core/facades/","text":"The Facade is the central concept in the Troika framework. It serves as the \"component\" unit for all objects, with the following responsibilities: Holding the object's current state, as a simple set of flat properties Synchronizing that state to a more complex model or imperative code Enforcing a simple, consistent object lifecycle In your app, you will define Facades to represent different types of objects in your scene. You will also make use of built-in Facade types that are specialized for specific purposes. Each Facade type is defined as a JavaScript class , extending the base Facade class. It has a few base methods, but otherwise each Facade class is free to define its own shape in the form of its public instance properties. Those properties will receive values from a scene descriptor or manual updates later on. See the base Facade class source for some additional class and method JSDoc. Why \"Facade\" instead of \"Component\"? The main reason for this naming choice was that \"Component\" is used by many other frameworks (React, Web Components, etc.) Since Troika will most likely be used as a subcomponent within another web framework, it felt confusing to have the same term referring to multiple things within the same app. Also, \"Facade\" is descriptive of its purpose: to create a simple public false-front that is backed by more complex code. Lifecycle \u00b6 The facade lifecycle is intentionally very simple: Instantiation \u00b6 The Facade class's constructor is called, and is always passed a single argument which is the parent facade instance. Troika facades are never reparented, so that parent will remain the same for the lifetime of the instance. The constructor is a good place to perform any initialization for things that will remain for the facade's lifetime, such as creating backing objects, setting up event listeners, etc. Updates \u00b6 This is where the facade instance receives its state. Since \"state\" is defined as the facade object's properties, updating that state simply consists of assigning a set of property values. This is usually done by copying a scene descriptor 's values directly onto the facade instance during a scene update pass. It can also be triggered manually via the facade's update method. This part of the lifecycle is also usually when the facade synchronizes its new state properties to its more complex backing object model. For properties that are \"standalone\", meaning they don't rely on any other properties, it is common for the facade class to define property accessors where the set() implementation updates the backing model right away. After all properties are updated, the special afterUpdate() lifecycle method will always be called. This method is where you can put any implementation code that uses multiple properties together, since you can rely on all those properties being up-to-date at this time. Destruction \u00b6 When a facade instance is removed from the scene tree, its destructor() method is called. This is where you can perform teardown logic, dispose of backing objects, remove event listeners, etc. Events \u00b6 Facades implement the EventTarget interface, so you can addEventListener just like you would a DOM element. Events dispatched this way can bubble, be cancelled, etc. as you'd expect. There is also a parallel messaging notification system that is used internally for sending large numbers of simple messages up the parent hierarchy in a highly optimized way. You likely won't need this, but see the notifyWorld() and onNotifyWorld() methods for more. See the section on Interactivity and Events for more. Example \u00b6 Here's a very simple example of creating a Facade class that synchronizes some properties to a backing SuperComplicatedObject: import { Facade } from 'troika-core' export class MyThingFacade extends Facade { // Instantiation: constructor ( parent ) { super ( parent ) // Init backing object: this . _impl = new SuperComplicatedObject () // Define state properties with initial values: this . width = 1 this . height = 1 this . depth = 1 this . color = '#123456' } // Getter/setter for directly syncing a standalone property: set color ( value ) { this . _impl . setColor ( value ) } get color () { return this . _impl . getColor () } // Handler for syncing interdependent properties: afterUpdate () { this . _impl . setDimensions ( this . width , this . height , this . depth ) super . afterUpdate () //don't forget the super call! } // Cleanup: destructor () { this . _impl . teardown () delete this . _impl super . destructor () } } This facade would then be created and updated using a scene descriptor like so: { key : 'thing1' , facade : MyThingFacade , width : 100 , height : 45 , depth : 23 , color : '#336699' } You'll learn more about scene descriptors in the next section. Special Facade Classes \u00b6 The base Facade class is a superclass of all facades, but you will seldom extend it directly. You'll instead most often use a more specialized facade type. Here are some you may want to be aware of: ParentFacade \u00b6 [Source] - This extends Facade with the ability to manage not only itself but also a set of child facades. At the end of its update phase it will recursively synchronize a set of child facade instances, based on an array of descriptor objects returned by its describeChildren() method (which by default returns the value of its .children property.) Most facade classes you will end up working with extend from ParentFacade . ListFacade \u00b6 [Source] - Inspired by D3 , this is an optimized way to update many of the same type of object that skips creating intermediate descriptor objects for each item. For details see Data Lists . Object3DFacade, Object2DFacade \u00b6 These are base facades for the troika-3d and troika-2d packages. If you are creating a 3D/2D graphical scene, you'll likely be extending these for most of your objects. See the docs for those packages for details. Notable Facade Methods \u00b6 update({...values}) \u00b6 This convenience method allows you to set one or more of a facade's property values, automatically invoking the afterUpdate lifecycle method and requesting a render frame . Calling this from within an event handler, for example, allows facade components to update their own state. myFacade . update ({ prop1 : 'newValue1' , prop2 : 'newValue2' }) requestRender() \u00b6 This method notifies the top-level world manager that this object has changed in some way that affects its visible rendering, so a rendering frame will be scheduled. getChildByKey(key) \u00b6 This method looks for a direct child facade that was created with a given key . This is not often needed. forEachChild(func) \u00b6 This method lets you iterate a ParentFacade instance's direct child facades, invoking func for each child. This is not often needed, since updating children is usually better served by update . traverse(func) \u00b6 This method lets you recursively traverse a facade instance and its entire subtree, depth-first, invoking func for each facade. This is not often needed, since updating a subtree is usually better served by update .","title":"Facades"},{"location":"troika-core/facades/#lifecycle","text":"The facade lifecycle is intentionally very simple:","title":"Lifecycle"},{"location":"troika-core/facades/#instantiation","text":"The Facade class's constructor is called, and is always passed a single argument which is the parent facade instance. Troika facades are never reparented, so that parent will remain the same for the lifetime of the instance. The constructor is a good place to perform any initialization for things that will remain for the facade's lifetime, such as creating backing objects, setting up event listeners, etc.","title":"Instantiation"},{"location":"troika-core/facades/#updates","text":"This is where the facade instance receives its state. Since \"state\" is defined as the facade object's properties, updating that state simply consists of assigning a set of property values. This is usually done by copying a scene descriptor 's values directly onto the facade instance during a scene update pass. It can also be triggered manually via the facade's update method. This part of the lifecycle is also usually when the facade synchronizes its new state properties to its more complex backing object model. For properties that are \"standalone\", meaning they don't rely on any other properties, it is common for the facade class to define property accessors where the set() implementation updates the backing model right away. After all properties are updated, the special afterUpdate() lifecycle method will always be called. This method is where you can put any implementation code that uses multiple properties together, since you can rely on all those properties being up-to-date at this time.","title":"Updates"},{"location":"troika-core/facades/#destruction","text":"When a facade instance is removed from the scene tree, its destructor() method is called. This is where you can perform teardown logic, dispose of backing objects, remove event listeners, etc.","title":"Destruction"},{"location":"troika-core/facades/#events","text":"Facades implement the EventTarget interface, so you can addEventListener just like you would a DOM element. Events dispatched this way can bubble, be cancelled, etc. as you'd expect. There is also a parallel messaging notification system that is used internally for sending large numbers of simple messages up the parent hierarchy in a highly optimized way. You likely won't need this, but see the notifyWorld() and onNotifyWorld() methods for more. See the section on Interactivity and Events for more.","title":"Events"},{"location":"troika-core/facades/#example","text":"Here's a very simple example of creating a Facade class that synchronizes some properties to a backing SuperComplicatedObject: import { Facade } from 'troika-core' export class MyThingFacade extends Facade { // Instantiation: constructor ( parent ) { super ( parent ) // Init backing object: this . _impl = new SuperComplicatedObject () // Define state properties with initial values: this . width = 1 this . height = 1 this . depth = 1 this . color = '#123456' } // Getter/setter for directly syncing a standalone property: set color ( value ) { this . _impl . setColor ( value ) } get color () { return this . _impl . getColor () } // Handler for syncing interdependent properties: afterUpdate () { this . _impl . setDimensions ( this . width , this . height , this . depth ) super . afterUpdate () //don't forget the super call! } // Cleanup: destructor () { this . _impl . teardown () delete this . _impl super . destructor () } } This facade would then be created and updated using a scene descriptor like so: { key : 'thing1' , facade : MyThingFacade , width : 100 , height : 45 , depth : 23 , color : '#336699' } You'll learn more about scene descriptors in the next section.","title":"Example"},{"location":"troika-core/facades/#special-facade-classes","text":"The base Facade class is a superclass of all facades, but you will seldom extend it directly. You'll instead most often use a more specialized facade type. Here are some you may want to be aware of:","title":"Special Facade Classes"},{"location":"troika-core/facades/#parentfacade","text":"[Source] - This extends Facade with the ability to manage not only itself but also a set of child facades. At the end of its update phase it will recursively synchronize a set of child facade instances, based on an array of descriptor objects returned by its describeChildren() method (which by default returns the value of its .children property.) Most facade classes you will end up working with extend from ParentFacade .","title":"ParentFacade"},{"location":"troika-core/facades/#listfacade","text":"[Source] - Inspired by D3 , this is an optimized way to update many of the same type of object that skips creating intermediate descriptor objects for each item. For details see Data Lists .","title":"ListFacade"},{"location":"troika-core/facades/#object3dfacade-object2dfacade","text":"These are base facades for the troika-3d and troika-2d packages. If you are creating a 3D/2D graphical scene, you'll likely be extending these for most of your objects. See the docs for those packages for details.","title":"Object3DFacade, Object2DFacade"},{"location":"troika-core/facades/#notable-facade-methods","text":"","title":"Notable Facade Methods"},{"location":"troika-core/facades/#updatevalues","text":"This convenience method allows you to set one or more of a facade's property values, automatically invoking the afterUpdate lifecycle method and requesting a render frame . Calling this from within an event handler, for example, allows facade components to update their own state. myFacade . update ({ prop1 : 'newValue1' , prop2 : 'newValue2' })","title":"update({...values})"},{"location":"troika-core/facades/#requestrender","text":"This method notifies the top-level world manager that this object has changed in some way that affects its visible rendering, so a rendering frame will be scheduled.","title":"requestRender()"},{"location":"troika-core/facades/#getchildbykeykey","text":"This method looks for a direct child facade that was created with a given key . This is not often needed.","title":"getChildByKey(key)"},{"location":"troika-core/facades/#foreachchildfunc","text":"This method lets you iterate a ParentFacade instance's direct child facades, invoking func for each child. This is not often needed, since updating children is usually better served by update .","title":"forEachChild(func)"},{"location":"troika-core/facades/#traversefunc","text":"This method lets you recursively traverse a facade instance and its entire subtree, depth-first, invoking func for each facade. This is not often needed, since updating a subtree is usually better served by update .","title":"traverse(func)"},{"location":"troika-core/interactivity-and-events/","text":"All Facades implement EventTarget , and mostly behave like DOM nodes in terms of how event listeners are added/removed and dispatched, including bubbling. In addition, Troika automatically dispatches certain handy events for you to utilize. Pointer Events \u00b6 Both troika-3d and troika-2d automatically intercept mouse events on the canvas, find any visible objects intersecting the pointer (\"raycasting\"), and dispatch corresponding events on those facades. This lets you treat 2D/3D objects like you would HTML DOM nodes in terms of pointer interactions. Note: Also see Troika 3D's Interactivity and Events documentation for additional details and capabilities provided by pointer events in Troika 3D scenes. By default, objects in the scene will not intercept the pointer unless they have a listener for one of the pointer-related events. This is both because 3D scenes in particular often have semi-transparent things that you wouldn't want to interfere with selecting objects beyond, and also an optimization to avoid expensive raycasting of things that aren't needed. If necessary, you can set a facade's pointerEvents property to true to force raycasting of objects without pointer event listeners. Setting it to false will prevent raycasting even if a listener is present. Pointer events can be subscribed do either using addEventListener with the event name, or by assigning a corresponding onEventName property in a descriptor object. Since these events all bubble, you can also listen for them on container facades (as long as a visible descendant is set to intercept pointerEvents .) The following basic events are suppported: Event Name Property Name mousemove onMouseMove mouseover onMouseOver mouseout onMouseOut mousedown onMouseDown mouseup onMouseUp click onClick dblclick onDoubleClick wheel onWheel In addition, the following events are supported for drag-and-drop interactions. These work like the corresponding events in the HTML Drag and Drop API , just with Facades instead of DOM nodes. Event Name Property Name dragstart onDragStart drag onDrag dragenter onDragEnter dragover onDragOver dragleave onDragLeave drop onDrop dragend onDragEnd Pointer States \u00b6 One of the most common uses of pointer events is to implement visual responses on hover or click. You can of course do this by adding \"mouseover\", \"mouseout\", etc. handlers which modify certain facade properties. But Troika also provides a handy declarative shortcut for this, pointerStates , which lets you define these effects much like :hover or :active in CSS. In your descriptor object , add a pointerStates property holding hover and/or active object values. Each of those defines a set of property values that will be applied upon mouseover/mousedown, and un-applied on mouseout/mouseup. For example: { key : 'foo' , facade : MyFacade , color : 'white' , pointerStates : { hover : { color : 'lightskyblue' }, active : { color : 'deepskyblue' } } } Other Events \u00b6 beforerender, afterrender \u00b6 These events are fired on any elements with listeners for them, immediately before and after the scene is rendered. This can be a good place to put logic that needs to run every frame. A beforerender handler is able to update the facade's state, prepare the backing implementation objects for rendering, etc. Note: this beforerender listener is different than Three.js's Object3D.onBeforeRender() -- it means \"before the scene renders\", not \"before this object renders\". The difference can be subtle; for example it will be fired for Group objects or other component facades without visible object renderings, and will fire even for objects that would be frustum-culled out of the rendered view. Custom Event Properties \u00b6 When designing Facade components that fire events, you may want to expose named properties for those events so that handlers can be added via scene descriptors. You can use the static Facade.defineEventProperty function to add getters/setters for this purpose: class TableFacade extends ParentFacade { onSomeAction () { this . dispatchEvent ( new CustomEvent ( 'flip' )) } } // Define an `onFlip` property that responds to the 'flip' event: Facade . defineEventProperty ( TableFacade , //the facade class 'onFlip' , //the name of the property 'flip' //the name of the event ) // ...descriptor later on: { facade : TableFacade , onFlip : e => { /* do something */ } }","title":"Interactivity and Events"},{"location":"troika-core/interactivity-and-events/#pointer-events","text":"Both troika-3d and troika-2d automatically intercept mouse events on the canvas, find any visible objects intersecting the pointer (\"raycasting\"), and dispatch corresponding events on those facades. This lets you treat 2D/3D objects like you would HTML DOM nodes in terms of pointer interactions. Note: Also see Troika 3D's Interactivity and Events documentation for additional details and capabilities provided by pointer events in Troika 3D scenes. By default, objects in the scene will not intercept the pointer unless they have a listener for one of the pointer-related events. This is both because 3D scenes in particular often have semi-transparent things that you wouldn't want to interfere with selecting objects beyond, and also an optimization to avoid expensive raycasting of things that aren't needed. If necessary, you can set a facade's pointerEvents property to true to force raycasting of objects without pointer event listeners. Setting it to false will prevent raycasting even if a listener is present. Pointer events can be subscribed do either using addEventListener with the event name, or by assigning a corresponding onEventName property in a descriptor object. Since these events all bubble, you can also listen for them on container facades (as long as a visible descendant is set to intercept pointerEvents .) The following basic events are suppported: Event Name Property Name mousemove onMouseMove mouseover onMouseOver mouseout onMouseOut mousedown onMouseDown mouseup onMouseUp click onClick dblclick onDoubleClick wheel onWheel In addition, the following events are supported for drag-and-drop interactions. These work like the corresponding events in the HTML Drag and Drop API , just with Facades instead of DOM nodes. Event Name Property Name dragstart onDragStart drag onDrag dragenter onDragEnter dragover onDragOver dragleave onDragLeave drop onDrop dragend onDragEnd","title":"Pointer Events"},{"location":"troika-core/interactivity-and-events/#pointer-states","text":"One of the most common uses of pointer events is to implement visual responses on hover or click. You can of course do this by adding \"mouseover\", \"mouseout\", etc. handlers which modify certain facade properties. But Troika also provides a handy declarative shortcut for this, pointerStates , which lets you define these effects much like :hover or :active in CSS. In your descriptor object , add a pointerStates property holding hover and/or active object values. Each of those defines a set of property values that will be applied upon mouseover/mousedown, and un-applied on mouseout/mouseup. For example: { key : 'foo' , facade : MyFacade , color : 'white' , pointerStates : { hover : { color : 'lightskyblue' }, active : { color : 'deepskyblue' } } }","title":"Pointer States"},{"location":"troika-core/interactivity-and-events/#other-events","text":"","title":"Other Events"},{"location":"troika-core/interactivity-and-events/#beforerender-afterrender","text":"These events are fired on any elements with listeners for them, immediately before and after the scene is rendered. This can be a good place to put logic that needs to run every frame. A beforerender handler is able to update the facade's state, prepare the backing implementation objects for rendering, etc. Note: this beforerender listener is different than Three.js's Object3D.onBeforeRender() -- it means \"before the scene renders\", not \"before this object renders\". The difference can be subtle; for example it will be fired for Group objects or other component facades without visible object renderings, and will fire even for objects that would be frustum-culled out of the rendered view.","title":"beforerender, afterrender"},{"location":"troika-core/interactivity-and-events/#custom-event-properties","text":"When designing Facade components that fire events, you may want to expose named properties for those events so that handlers can be added via scene descriptors. You can use the static Facade.defineEventProperty function to add getters/setters for this purpose: class TableFacade extends ParentFacade { onSomeAction () { this . dispatchEvent ( new CustomEvent ( 'flip' )) } } // Define an `onFlip` property that responds to the 'flip' event: Facade . defineEventProperty ( TableFacade , //the facade class 'onFlip' , //the name of the property 'flip' //the name of the event ) // ...descriptor later on: { facade : TableFacade , onFlip : e => { /* do something */ } }","title":"Custom Event Properties"},{"location":"troika-core/scene-descriptors/","text":"The scene descriptor describes the structure of your scene at a point in time. As you apply new scene descriptors over time based on the changing state of your application, Troika tracks the differences from one descriptor to the next, and creates/destroys/updates a tree of Facade instances to match. Describing your scene declaratively this way removes the mental overhead of having to track and modify individual objects over time, making your scenes much easier to understand and debug. If you are familiar with React , this will feel very familiar. In fact Troika's scene descriptor model is highly inspired by React. The scene descriptor behaves very much like JSX descriptors, and Troika's Facades are in some ways similar to React's Components. A Basic Descriptor \u00b6 A descriptor is just a plain JS object with a set of properties. Here's a basic example: { facade : BallFacade , x : 1 , y : 5 , z : - 10 , color : 0x3333cc } The only property that a descriptor must include is facade . It defines the specific Facade subclass that will be instantiated for this object. All the other properties are simply copied to that facade instance when the scene is updated. That specific facade's implementation controls what those properties mean in terms of their representation in your graphical scene. Typically this means syncing those property changes to a more complex underlying API such as a Three.js mesh/geometry/material. While Troika has a few built-in facade types, for the most part they will be something that you must implement for the kinds of objects in your scene. See Facade Basics for details and simple examples. Special Descriptor Properties \u00b6 While most properties are just copied to the facade instance, a few of them have special meanings: key \u00b6 A descriptor may include a key string property, identifying the specific facade instance corresponding to that descriptor object. The key must be unique among its siblings within a given parent. If omitted, Troika will generate a key internally based on the facade subclass and position among siblings. However it is recommended that you always include an explicit key , to avoid sometimes confusing situations with instance swapping, particularly when using animations and transitions. { facade : BallFacade , key : 'ball1' , x : - 2 }, { facade : BallFacade , key : 'ball2' , x : 2 } children \u00b6 Many Troika facades (those inheriting from ParentFacade ) allow a children property, pointing to an array of child descriptors, or a single child descriptor object if there is only one. { facade : Group3DFacade , key : 'group' , rotateZ : Math . PI / 2 , children : [ { facade : BallFacade , key : 'ball1' , x : - 2 }, { facade : BallFacade , key : 'ball2' , x : 2 } ] } transition , animation , exitAnimation \u00b6 A descriptor with one of these properties causes the instantiated Facade class to be wrapped as Animatable , allowing you to declaratively define how other property values should change over time. These are based very closely on CSS Transitions and CSS Keyframe Animations , and are covered in detail in Animations and Transitions . pointerStates \u00b6 Similarly, the presence of a pointerStates property will wrap the facade instance so that it automatically changes its state in response to pointer events. This gives you declarative control over styling for hover and active states, much like CSS pseudoclasses, without having to write imperative event handlers every time. This is covered in detail in Interactivity and Events . ref \u00b6 If your code needs a reference to the Facade object instantiated for a given descriptor, you can give it a ref property pointing to a function. That function will be called, passed the facade instance as its argument, when the facade is created. It will also be called, with null as its argument, when the facade is destroyed (removed from the scene.) If the ref is reassigned to a different function during an update, the old one will be called with null and the new one will be called with the facade instance. This is usually not what you want, so to avoid this churn make sure the exact same function is passed across updates. function ballRefFunction ( ballFacade ) { console . log ( 'BallFacade was ' + ( ballFacade ? 'created' : 'destroyed' )) } //... { facade : BallFacade , key : 'ball' , ref : ballRefFunction } As in React, there is seldom a need to use ref , but it can be a useful tool in those rare cases. Data Lists \u00b6 In cases where you need to describe a large number of scene objects, such as when you are mapping from a large set of data items, it is inefficient to create a large array of children with a scene descriptor object for each item. Troika provides a ListFacade to handle these cases more efficiently. Instead of a descriptor object for each item, you define a single descriptor object bound to a data array, with a template object that describes how the items in that data array should be mapped to facade instances. import { ListFacade } from 'troika-3d' //... { facade : ListFacade , key : 'myList' , data : myArrayOfDataItems , template : { facade : BallFacade , key : d => d . id , x : ( d , i ) => i * 2 , y : d => d . value / maxValue * 10 , z : - 10 } } This pattern is inspired by how d3.js binds data to attributes without creating a full set of intermediary objects. Each property in the template can either be a constant literal value (e.g. a number or string), or a function. Literals will be copied directly to each spawned child. Functions will be called for each item, passing three arguments: the current item from the data array, the current index in the array, and the full array. The value returned by the function will be copied to that child facade. In cases where you want an actual function to be copied, such as assigning event handlers, you will need to wrap those in a function that returns your function. template : { //... onClick : () => this . onBallClicked } Alternate JSX syntax \u00b6 If you are using React for the rest of your application, it can sometimes be confusing to have to step between using JSX for React content descriptors and the plain JS object descriptors for Troika content. To smooth this over, Troika is able to accept JSX elements in place of most JS object descriptors, assuming your build pipeline pre-transforms JSX to React.createElement() calls. When representing Troika descriptors in JSX, the facade value is used as the JSX element name, children are represented as nested JSX child elements, and all other properties are written as JSX attributes. For example: { facade : Group3DFacade , key : 'grp' , rotateZ : Math . PI / 2 , children : [ { facade : BallFacade , key : 'ball1' , x : - 2 }, { facade : BallFacade , key : 'ball2' , x : 2 } ] } ...is equivalent to: <Group3DFacade key=\"group\" rotateZ={Math.PI / 2} > <BallFacade key=\"ball1\" x={-2} /> <BallFacade key=\"ball2\" x={2} /> </Group3DFacade> While the JSX sugar can often be more readable, it does have a slight performance impact due to more transient objects being created and React.createElement() 's own internal logic being run for each element. Try to avoid it and stick with plain JS descriptors when your scene contains a large number of them.","title":"Scene Descriptors"},{"location":"troika-core/scene-descriptors/#a-basic-descriptor","text":"A descriptor is just a plain JS object with a set of properties. Here's a basic example: { facade : BallFacade , x : 1 , y : 5 , z : - 10 , color : 0x3333cc } The only property that a descriptor must include is facade . It defines the specific Facade subclass that will be instantiated for this object. All the other properties are simply copied to that facade instance when the scene is updated. That specific facade's implementation controls what those properties mean in terms of their representation in your graphical scene. Typically this means syncing those property changes to a more complex underlying API such as a Three.js mesh/geometry/material. While Troika has a few built-in facade types, for the most part they will be something that you must implement for the kinds of objects in your scene. See Facade Basics for details and simple examples.","title":"A Basic Descriptor"},{"location":"troika-core/scene-descriptors/#special-descriptor-properties","text":"While most properties are just copied to the facade instance, a few of them have special meanings:","title":"Special Descriptor Properties"},{"location":"troika-core/scene-descriptors/#key","text":"A descriptor may include a key string property, identifying the specific facade instance corresponding to that descriptor object. The key must be unique among its siblings within a given parent. If omitted, Troika will generate a key internally based on the facade subclass and position among siblings. However it is recommended that you always include an explicit key , to avoid sometimes confusing situations with instance swapping, particularly when using animations and transitions. { facade : BallFacade , key : 'ball1' , x : - 2 }, { facade : BallFacade , key : 'ball2' , x : 2 }","title":"key"},{"location":"troika-core/scene-descriptors/#children","text":"Many Troika facades (those inheriting from ParentFacade ) allow a children property, pointing to an array of child descriptors, or a single child descriptor object if there is only one. { facade : Group3DFacade , key : 'group' , rotateZ : Math . PI / 2 , children : [ { facade : BallFacade , key : 'ball1' , x : - 2 }, { facade : BallFacade , key : 'ball2' , x : 2 } ] }","title":"children"},{"location":"troika-core/scene-descriptors/#transition-animation-exitanimation","text":"A descriptor with one of these properties causes the instantiated Facade class to be wrapped as Animatable , allowing you to declaratively define how other property values should change over time. These are based very closely on CSS Transitions and CSS Keyframe Animations , and are covered in detail in Animations and Transitions .","title":"transition, animation, exitAnimation"},{"location":"troika-core/scene-descriptors/#pointerstates","text":"Similarly, the presence of a pointerStates property will wrap the facade instance so that it automatically changes its state in response to pointer events. This gives you declarative control over styling for hover and active states, much like CSS pseudoclasses, without having to write imperative event handlers every time. This is covered in detail in Interactivity and Events .","title":"pointerStates"},{"location":"troika-core/scene-descriptors/#ref","text":"If your code needs a reference to the Facade object instantiated for a given descriptor, you can give it a ref property pointing to a function. That function will be called, passed the facade instance as its argument, when the facade is created. It will also be called, with null as its argument, when the facade is destroyed (removed from the scene.) If the ref is reassigned to a different function during an update, the old one will be called with null and the new one will be called with the facade instance. This is usually not what you want, so to avoid this churn make sure the exact same function is passed across updates. function ballRefFunction ( ballFacade ) { console . log ( 'BallFacade was ' + ( ballFacade ? 'created' : 'destroyed' )) } //... { facade : BallFacade , key : 'ball' , ref : ballRefFunction } As in React, there is seldom a need to use ref , but it can be a useful tool in those rare cases.","title":"ref"},{"location":"troika-core/scene-descriptors/#data-lists","text":"In cases where you need to describe a large number of scene objects, such as when you are mapping from a large set of data items, it is inefficient to create a large array of children with a scene descriptor object for each item. Troika provides a ListFacade to handle these cases more efficiently. Instead of a descriptor object for each item, you define a single descriptor object bound to a data array, with a template object that describes how the items in that data array should be mapped to facade instances. import { ListFacade } from 'troika-3d' //... { facade : ListFacade , key : 'myList' , data : myArrayOfDataItems , template : { facade : BallFacade , key : d => d . id , x : ( d , i ) => i * 2 , y : d => d . value / maxValue * 10 , z : - 10 } } This pattern is inspired by how d3.js binds data to attributes without creating a full set of intermediary objects. Each property in the template can either be a constant literal value (e.g. a number or string), or a function. Literals will be copied directly to each spawned child. Functions will be called for each item, passing three arguments: the current item from the data array, the current index in the array, and the full array. The value returned by the function will be copied to that child facade. In cases where you want an actual function to be copied, such as assigning event handlers, you will need to wrap those in a function that returns your function. template : { //... onClick : () => this . onBallClicked }","title":"Data Lists"},{"location":"troika-core/scene-descriptors/#alternate-jsx-syntax","text":"If you are using React for the rest of your application, it can sometimes be confusing to have to step between using JSX for React content descriptors and the plain JS object descriptors for Troika content. To smooth this over, Troika is able to accept JSX elements in place of most JS object descriptors, assuming your build pipeline pre-transforms JSX to React.createElement() calls. When representing Troika descriptors in JSX, the facade value is used as the JSX element name, children are represented as nested JSX child elements, and all other properties are written as JSX attributes. For example: { facade : Group3DFacade , key : 'grp' , rotateZ : Math . PI / 2 , children : [ { facade : BallFacade , key : 'ball1' , x : - 2 }, { facade : BallFacade , key : 'ball2' , x : 2 } ] } ...is equivalent to: <Group3DFacade key=\"group\" rotateZ={Math.PI / 2} > <BallFacade key=\"ball1\" x={-2} /> <BallFacade key=\"ball2\" x={2} /> </Group3DFacade> While the JSX sugar can often be more readable, it does have a slight performance impact due to more transient objects being created and React.createElement() 's own internal logic being run for each element. Try to avoid it and stick with plain JS descriptors when your scene contains a large number of them.","title":"Alternate JSX syntax"},{"location":"troika-three-text/","text":"Troika Text for Three.js \u00b6 The troika-three-text package provides high quality text rendering in Three.js scenes, using signed distance fields (SDF) and antialiasing using standard derivatives. Rather than relying on pre-generated SDF textures, this parses font files (.ttf, .otf, .woff) directly using Typr , and generates the SDF atlas for glyphs on-the-fly as they are used. It also handles proper kerning, ligature glyph substitution, right-to-left/bidirectional layout, and joined scripts like Arabic. All font parsing, SDF generation, and glyph layout is performed in a web worker to prevent frame drops. Once the SDFs are generated, it assembles a geometry that positions all the glyphs, and patches any Three.js Material with the proper shader code for rendering the SDFs. This means you can still benefit from all the features of Three.js's built-in materials like lighting, physically-based rendering, shadows, and fog. Demos \u00b6 With the Troika scene management framework With react-three-fiber With a video texture With the Material Icons font With Other Frameworks \u00b6 In the drei utilities for react-three-fiber As an A-Frame component As a Web Component in three-elements Screenshots \u00b6 Installation \u00b6 Get it from NPM : npm install troika-three-text You will also need to install a compatible version of Three.js ; see the notes on Three.js versions in the Getting Started docs for details. npm install three Usage \u00b6 import { Text } from 'troika-three-text' You can then use the Text class like any other Three.js mesh: // Create: const myText = new Text () myScene . add ( myText ) // Set properties to configure: myText . text = 'Hello world!' myText . fontSize = 0.2 myText . position . z = - 2 myText . color = 0x9966FF // Update the rendering: myText . sync () It's a good idea to call the .sync() method after changing any properties that would affect the text's layout. If you don't, it will be called automatically on the next render frame, but calling it yourself can get the result sooner. When you're done with the Text instance, be sure to call dispose on it to prevent a memory leak: myScene . remove ( myText ) myText . dispose () Supported properties \u00b6 Instances of Text support the following configuration properties: text \u00b6 The string of text to be rendered. Newlines and repeating whitespace characters are honored. Default: none anchor \u00b6 This property is deprecated as of version 0.24.0; use anchorX and anchorY instead. anchorX \u00b6 Defines the horizontal position in the text block that should line up with the local origin. Can be specified as a numeric x position in local units, a string percentage of the total text block width e.g. '25%' , or one of the following keyword strings: 'left' , 'center' , or 'right' . Default: 0 anchorY \u00b6 Defines the vertical position in the text block that should line up with the local origin. Can be specified as a numeric y position in local units (note: down is negative y), a string percentage of the total text block height e.g. '25%' , or one of the following keyword strings: 'top' , 'top-baseline' , 'middle' , 'bottom-baseline' , or 'bottom' . Default: 0 clipRect \u00b6 If specified, defines the [minX, minY, maxX, maxY] of a rectangle outside of which all pixels will be discarded. This can be used for example to clip overflowing text when whiteSpace='nowrap' . Default: none color \u00b6 This is a shortcut for setting the color of the text's material . You can use this if you don't want to specify a whole custom material and just want to change its color. Use the material property if you want to control aspects of the material other than its color. Default: none - uses the color of the material curveRadius \u00b6 Defines a cylindrical radius along which the text's plane will be curved. Positive numbers put the cylinder's centerline (oriented vertically) that distance in front of the text, for a concave curvature, while negative numbers put it behind the text for a convex curvature. The centerline will be aligned with the text's local origin; you can use anchorX to offset it. Since each glyph is by default rendered with a simple quad, each glyph remains a flat plane internally. You can use glyphGeometryDetail to add more vertices for curvature inside glyphs. Default: 0 depthOffset \u00b6 This is a shortcut for setting the material's polygonOffset and related properties , which can be useful in preventing z-fighting when this text is laid on top of another plane in the scene. Positive numbers are further from the camera, negatives closer. Be aware that while this can help with z-fighting, it does not affect the rendering order; if the text renders before the content behind it, you may see antialiasing pixels that appear too dark or light. You may need to also change the text mesh's renderOrder , or set its z position a fraction closer to the camera, to ensure the text renders after background objects. Default: 0 direction \u00b6 Sets the base direction for the text. The default value of \"auto\" will choose a direction based on the text's content according to the bidi spec. A value of \"ltr\" or \"rtl\" will force the direction. Default: 'auto' fillOpacity \u00b6 Controls the opacity of just the glyph's fill area, separate from any configured strokeOpacity , outlineOpacity , and the material's opacity . A fillOpacity of 0 will make the fill invisible, leaving just the stroke and/or outline. Default: 1 font \u00b6 The URL of a custom font file to be used. Supported font formats are: * .ttf * .otf * .woff (.woff2 is not supported) Default: The Roboto font loaded from Google Fonts CDN fontSize \u00b6 The em-height at which to render the font, in local world units. Default: 0.1 glyphGeometryDetail \u00b6 The number of vertical/horizontal segments that make up each glyph's rectangular plane. This can be increased to provide more geometrical detail for custom vertex shader effects, for example. Default: 1 gpuAccelerateSDF \u00b6 When true , the SDF generation process will be GPU-accelerated with WebGL when possible, making it much faster especially for complex glyphs, and falling back to a JavaScript version executed in web workers when support isn't available. It should automatically detect support, but it's still somewhat experimental, so you can set it to false to force it to use the JS version if you encounter issues with it. Default: true letterSpacing \u00b6 Sets a uniform adjustment to spacing between letters after kerning is applied, in local world units. Positive numbers increase spacing and negative numbers decrease it. Default: 0 lineHeight \u00b6 Sets the height of each line of text. Can either be 'normal' which chooses a reasonable height based on the chosen font's ascender/descender metrics, or a number that is interpreted as a multiple of the fontSize . Default: 'normal' material \u00b6 Defines a Three.js Material instance to be used as a base when rendering the text. This material will be automatically replaced with a new material derived from it, that adds shader code to decrease the alpha for each fragment (pixel) outside the text glyphs, with antialiasing. By default it will derive from a simple white `MeshBasicMaterial, but you can use any of the other mesh materials to gain other features like lighting, texture maps, etc. Also see the color shortcut property. Note that because your material instance is replaced by a derived material instance, any changes you make to your original material will not be reflected in the derived version. If you need to modify properties of the material afterward, be sure you get a new reference to the derived version: // Bad: text . material = myOrigMaterial myOrigMaterial . opacity = 0.5 // Good: text . material = myOrigMaterial text . material . opacity = 0.5 Default: a MeshBasicMaterial instance maxWidth \u00b6 The maximum width of the text block, above which text may start wrapping according to the whiteSpace and overflowWrap properties. Default: Infinity , meaning text will never wrap outlineBlur \u00b6 Specifies a blur radius applied to the outer edge of the text's outlineWidth . If the outlineWidth is zero, the blur will be applied at the glyph edge, like CSS's text-shadow blur radius. A blur plus a nonzero outlineWidth can give a solid outline with a fuzzy outer edge. The blur radius can be specified as either an absolute number in local units, or as a percentage string e.g. \"12%\" which is treated as a percentage of the fontSize . Default: 0 outlineColor \u00b6 The color to use for the text outline when outlineWidth , outlineBlur , and/or outlineOffsetX/Y are set. Accepts a ThreeJS Color object, or a number/string accepted by Color#set . Default: black outlineOffsetX , outlineOffsetY \u00b6 These define a horizontal and vertical offset of the text outline. Using an offset with outlineWidth: 0 creates a drop-shadow effect like CSS's text-shadow ; also see outlineBlur . The offsets can be specified as either an absolute number in local units, or as a percentage string e.g. \"12%\" which is treated as a percentage of the fontSize . Default: 0 outlineOpacity \u00b6 Sets the opacity of a configured text outline, in the range 0 to 1 . Default: 1 outlineWidth \u00b6 The width of an outline/halo to be drawn around each text glyph using the outlineColor and outlineOpacity . This can help improve readability when the text is displayed against a background of low or varying contrast. The width can be specified as either an absolute number in local units, or as a percentage string e.g. \"10%\" which is interpreted as a percentage of the fontSize . Default: 0 overflowWrap \u00b6 Defines how text wraps if the whiteSpace property is 'normal' . Can be either 'normal' to break at whitespace characters, or 'break-word' to allow breaking within words. Default: 'normal' sdfGlyphSize \u00b6 Allows overriding the default size of each glyph's SDF (signed distance field) used when rendering this text instance. This must be a power-of-two number. Larger sizes can improve the quality of glyph rendering by increasing the sharpness of corners and preventing loss of very thin lines, at the expense of increased memory footprint and longer SDF generation time. Default: 64 strokeColor \u00b6 The color of the text stroke, when strokeWidth is nonzero. Accepts a ThreeJS Color object, or a number/string accepted by Color#set . Default: grey strokeOpacity \u00b6 The opacity of the text stroke, when strokeWidth is nonzero. Accepts a number from 0 to 1 . Default: 1 strokeWidth \u00b6 Sets the width of a stroke drawn inside the edge of each text glyph, using the strokeColor and strokeOpacity . The width can be specified as either an absolute number in local units, or as a percentage string e.g. \"10%\" which is interpreted as a percentage of the fontSize . Default: 0 textAlign \u00b6 The horizontal alignment of each line of text within the overall text bounding box. Can be one of 'left' , 'right' , 'center' , or 'justify' . Default: 'left' textIndent \u00b6 An indentation applied to the first character of each hard newline. Behaves like CSS text-indent . Default: 0 whiteSpace \u00b6 Defines whether text should wrap when a line reaches the maxWidth . Can be either 'normal' , to allow wrapping according to the overflowWrap property, or 'nowrap' to prevent wrapping. Note that 'normal' in this context does honor newline characters to manually break lines, making it behave more like 'pre-wrap' does in CSS. Default: 'normal' Handling Asynchronous Updates \u00b6 Since the text processing occurs in a web worker, it is by definition asynchronous. This means that you can't rely on the text being visible or having a complete geometry immediately. If you need to do things like access the geometry's boundingSphere or the textRenderInfo , you will have to listen for completion. You can do this two ways: Pass a callback function when you call the sync method: myText . sync (() => { // code to execute after sync completes... }) This is best when you want to only react to that specific sync call. Keep in mind that the callback will not execute if the text is already fully synced. Add a listener for the synccomplete event: myText . addEventListener ( 'synccomplete' , () => { // code to execute after sync completes... }) This will fire after every sync, no matter who invoked it. This is best if you need to react to all syncs, for example to trigger a manual canvas render. You can also listen for the syncstart event if you need to react to the initiation of a sync call, e.g. to set some sort of \"waiting\" state while the text is being processed. Preloading \u00b6 To avoid long pauses when first displaying a piece of text in your scene, you can preload fonts and optionally pre-generate the SDF textures for particular glyphs up front: import { preloadFont } from 'troika-three-text' myApp . showLoadingScreen () preloadFont ( { font : 'path/to/myfontfile.woff' , characters : 'abcdefghijklmnopqrstuvwxyz' }, () => { myApp . showScene () } ) The arguments are: options options.font - The URL of the font file to preload. If null is passed, this will preload the default font. options.characters - A string or array of string character sequences for which to pre-generate glyph SDF textures. Note that this will honor ligature substitution, so you may need to specify ligature sequences in addition to their individual characters to get all possible glyphs, e.g. [\"t\", \"h\", \"th\"] to get the \"t\" and \"h\" glyphs plus the \"th\" glyph. options.sdfGlyphSize - The size at which to prerender the SDFs for the characters glyphs. See the sdfGlyphSize config property on Text for details about SDF sizes. If not specified, will use the default SDF size. callback - A function that will be called when the preloading is complete. Postprocessing \u00b6 It is possible to use Text within scenes that utilize the postprocessing library for applying image effects. However, you must enable a special mode in that library that allows Text 's custom material to be honored. Just do the following once somewhere in your code: import { OverrideMaterialManager } from 'postprocessing' OverrideMaterialManager . workaroundEnabled = true Carets and Selection Ranges \u00b6 In addition to rendering text, it is possible to access positioning information for caret placement and selection ranges. To access that info, use the getCaretAtPoint and getSelectionRects utility functions. Both of these functions take a textRenderInfo object as input, which you can get from the Text object's textRenderInfo property after sync has completed. See \"Handling Asynchronous Updates\" above for how to react to sync completion events. getCaretAtPoint(textRenderInfo, x, y) \u00b6 This returns the caret position nearest to a given x/y position in the local text plane. This is useful for placing an editing caret based on a click or ther raycasted event. The return value is an object with the following properties: x - x position of the caret y - y position of the caret's bottom height - height of the caret, based on the current fontSize and lineHeight charIndex - the index in the original input string of this caret's target character. The caret will be for the position before that character. For the final caret position, this will be equal to the string length. For ligature glyphs, this will be for the first character in the ligature sequence. getSelectionRects(textRenderInfo, start, end) \u00b6 This returns a list of rectangles covering all the characters within a given character range. This is useful for highlighting a selection range. The return value is an array of objects, each with {left, top, right, bottom} properties in the local text plane.","title":"Troika 3D Text"},{"location":"troika-three-text/#troika-text-for-threejs","text":"The troika-three-text package provides high quality text rendering in Three.js scenes, using signed distance fields (SDF) and antialiasing using standard derivatives. Rather than relying on pre-generated SDF textures, this parses font files (.ttf, .otf, .woff) directly using Typr , and generates the SDF atlas for glyphs on-the-fly as they are used. It also handles proper kerning, ligature glyph substitution, right-to-left/bidirectional layout, and joined scripts like Arabic. All font parsing, SDF generation, and glyph layout is performed in a web worker to prevent frame drops. Once the SDFs are generated, it assembles a geometry that positions all the glyphs, and patches any Three.js Material with the proper shader code for rendering the SDFs. This means you can still benefit from all the features of Three.js's built-in materials like lighting, physically-based rendering, shadows, and fog.","title":"Troika Text for Three.js"},{"location":"troika-three-text/#demos","text":"With the Troika scene management framework With react-three-fiber With a video texture With the Material Icons font","title":"Demos"},{"location":"troika-three-text/#with-other-frameworks","text":"In the drei utilities for react-three-fiber As an A-Frame component As a Web Component in three-elements","title":"With Other Frameworks"},{"location":"troika-three-text/#screenshots","text":"","title":"Screenshots"},{"location":"troika-three-text/#installation","text":"Get it from NPM : npm install troika-three-text You will also need to install a compatible version of Three.js ; see the notes on Three.js versions in the Getting Started docs for details. npm install three","title":"Installation"},{"location":"troika-three-text/#usage","text":"import { Text } from 'troika-three-text' You can then use the Text class like any other Three.js mesh: // Create: const myText = new Text () myScene . add ( myText ) // Set properties to configure: myText . text = 'Hello world!' myText . fontSize = 0.2 myText . position . z = - 2 myText . color = 0x9966FF // Update the rendering: myText . sync () It's a good idea to call the .sync() method after changing any properties that would affect the text's layout. If you don't, it will be called automatically on the next render frame, but calling it yourself can get the result sooner. When you're done with the Text instance, be sure to call dispose on it to prevent a memory leak: myScene . remove ( myText ) myText . dispose ()","title":"Usage"},{"location":"troika-three-text/#supported-properties","text":"Instances of Text support the following configuration properties:","title":"Supported properties"},{"location":"troika-three-text/#text","text":"The string of text to be rendered. Newlines and repeating whitespace characters are honored. Default: none","title":"text"},{"location":"troika-three-text/#anchor","text":"This property is deprecated as of version 0.24.0; use anchorX and anchorY instead.","title":"anchor"},{"location":"troika-three-text/#anchorx","text":"Defines the horizontal position in the text block that should line up with the local origin. Can be specified as a numeric x position in local units, a string percentage of the total text block width e.g. '25%' , or one of the following keyword strings: 'left' , 'center' , or 'right' . Default: 0","title":"anchorX"},{"location":"troika-three-text/#anchory","text":"Defines the vertical position in the text block that should line up with the local origin. Can be specified as a numeric y position in local units (note: down is negative y), a string percentage of the total text block height e.g. '25%' , or one of the following keyword strings: 'top' , 'top-baseline' , 'middle' , 'bottom-baseline' , or 'bottom' . Default: 0","title":"anchorY"},{"location":"troika-three-text/#cliprect","text":"If specified, defines the [minX, minY, maxX, maxY] of a rectangle outside of which all pixels will be discarded. This can be used for example to clip overflowing text when whiteSpace='nowrap' . Default: none","title":"clipRect"},{"location":"troika-three-text/#color","text":"This is a shortcut for setting the color of the text's material . You can use this if you don't want to specify a whole custom material and just want to change its color. Use the material property if you want to control aspects of the material other than its color. Default: none - uses the color of the material","title":"color"},{"location":"troika-three-text/#curveradius","text":"Defines a cylindrical radius along which the text's plane will be curved. Positive numbers put the cylinder's centerline (oriented vertically) that distance in front of the text, for a concave curvature, while negative numbers put it behind the text for a convex curvature. The centerline will be aligned with the text's local origin; you can use anchorX to offset it. Since each glyph is by default rendered with a simple quad, each glyph remains a flat plane internally. You can use glyphGeometryDetail to add more vertices for curvature inside glyphs. Default: 0","title":"curveRadius"},{"location":"troika-three-text/#depthoffset","text":"This is a shortcut for setting the material's polygonOffset and related properties , which can be useful in preventing z-fighting when this text is laid on top of another plane in the scene. Positive numbers are further from the camera, negatives closer. Be aware that while this can help with z-fighting, it does not affect the rendering order; if the text renders before the content behind it, you may see antialiasing pixels that appear too dark or light. You may need to also change the text mesh's renderOrder , or set its z position a fraction closer to the camera, to ensure the text renders after background objects. Default: 0","title":"depthOffset"},{"location":"troika-three-text/#direction","text":"Sets the base direction for the text. The default value of \"auto\" will choose a direction based on the text's content according to the bidi spec. A value of \"ltr\" or \"rtl\" will force the direction. Default: 'auto'","title":"direction"},{"location":"troika-three-text/#fillopacity","text":"Controls the opacity of just the glyph's fill area, separate from any configured strokeOpacity , outlineOpacity , and the material's opacity . A fillOpacity of 0 will make the fill invisible, leaving just the stroke and/or outline. Default: 1","title":"fillOpacity"},{"location":"troika-three-text/#font","text":"The URL of a custom font file to be used. Supported font formats are: * .ttf * .otf * .woff (.woff2 is not supported) Default: The Roboto font loaded from Google Fonts CDN","title":"font"},{"location":"troika-three-text/#fontsize","text":"The em-height at which to render the font, in local world units. Default: 0.1","title":"fontSize"},{"location":"troika-three-text/#glyphgeometrydetail","text":"The number of vertical/horizontal segments that make up each glyph's rectangular plane. This can be increased to provide more geometrical detail for custom vertex shader effects, for example. Default: 1","title":"glyphGeometryDetail"},{"location":"troika-three-text/#gpuacceleratesdf","text":"When true , the SDF generation process will be GPU-accelerated with WebGL when possible, making it much faster especially for complex glyphs, and falling back to a JavaScript version executed in web workers when support isn't available. It should automatically detect support, but it's still somewhat experimental, so you can set it to false to force it to use the JS version if you encounter issues with it. Default: true","title":"gpuAccelerateSDF"},{"location":"troika-three-text/#letterspacing","text":"Sets a uniform adjustment to spacing between letters after kerning is applied, in local world units. Positive numbers increase spacing and negative numbers decrease it. Default: 0","title":"letterSpacing"},{"location":"troika-three-text/#lineheight","text":"Sets the height of each line of text. Can either be 'normal' which chooses a reasonable height based on the chosen font's ascender/descender metrics, or a number that is interpreted as a multiple of the fontSize . Default: 'normal'","title":"lineHeight"},{"location":"troika-three-text/#material","text":"Defines a Three.js Material instance to be used as a base when rendering the text. This material will be automatically replaced with a new material derived from it, that adds shader code to decrease the alpha for each fragment (pixel) outside the text glyphs, with antialiasing. By default it will derive from a simple white `MeshBasicMaterial, but you can use any of the other mesh materials to gain other features like lighting, texture maps, etc. Also see the color shortcut property. Note that because your material instance is replaced by a derived material instance, any changes you make to your original material will not be reflected in the derived version. If you need to modify properties of the material afterward, be sure you get a new reference to the derived version: // Bad: text . material = myOrigMaterial myOrigMaterial . opacity = 0.5 // Good: text . material = myOrigMaterial text . material . opacity = 0.5 Default: a MeshBasicMaterial instance","title":"material"},{"location":"troika-three-text/#maxwidth","text":"The maximum width of the text block, above which text may start wrapping according to the whiteSpace and overflowWrap properties. Default: Infinity , meaning text will never wrap","title":"maxWidth"},{"location":"troika-three-text/#outlineblur","text":"Specifies a blur radius applied to the outer edge of the text's outlineWidth . If the outlineWidth is zero, the blur will be applied at the glyph edge, like CSS's text-shadow blur radius. A blur plus a nonzero outlineWidth can give a solid outline with a fuzzy outer edge. The blur radius can be specified as either an absolute number in local units, or as a percentage string e.g. \"12%\" which is treated as a percentage of the fontSize . Default: 0","title":"outlineBlur"},{"location":"troika-three-text/#outlinecolor","text":"The color to use for the text outline when outlineWidth , outlineBlur , and/or outlineOffsetX/Y are set. Accepts a ThreeJS Color object, or a number/string accepted by Color#set . Default: black","title":"outlineColor"},{"location":"troika-three-text/#outlineoffsetx-outlineoffsety","text":"These define a horizontal and vertical offset of the text outline. Using an offset with outlineWidth: 0 creates a drop-shadow effect like CSS's text-shadow ; also see outlineBlur . The offsets can be specified as either an absolute number in local units, or as a percentage string e.g. \"12%\" which is treated as a percentage of the fontSize . Default: 0","title":"outlineOffsetX, outlineOffsetY"},{"location":"troika-three-text/#outlineopacity","text":"Sets the opacity of a configured text outline, in the range 0 to 1 . Default: 1","title":"outlineOpacity"},{"location":"troika-three-text/#outlinewidth","text":"The width of an outline/halo to be drawn around each text glyph using the outlineColor and outlineOpacity . This can help improve readability when the text is displayed against a background of low or varying contrast. The width can be specified as either an absolute number in local units, or as a percentage string e.g. \"10%\" which is interpreted as a percentage of the fontSize . Default: 0","title":"outlineWidth"},{"location":"troika-three-text/#overflowwrap","text":"Defines how text wraps if the whiteSpace property is 'normal' . Can be either 'normal' to break at whitespace characters, or 'break-word' to allow breaking within words. Default: 'normal'","title":"overflowWrap"},{"location":"troika-three-text/#sdfglyphsize","text":"Allows overriding the default size of each glyph's SDF (signed distance field) used when rendering this text instance. This must be a power-of-two number. Larger sizes can improve the quality of glyph rendering by increasing the sharpness of corners and preventing loss of very thin lines, at the expense of increased memory footprint and longer SDF generation time. Default: 64","title":"sdfGlyphSize"},{"location":"troika-three-text/#strokecolor","text":"The color of the text stroke, when strokeWidth is nonzero. Accepts a ThreeJS Color object, or a number/string accepted by Color#set . Default: grey","title":"strokeColor"},{"location":"troika-three-text/#strokeopacity","text":"The opacity of the text stroke, when strokeWidth is nonzero. Accepts a number from 0 to 1 . Default: 1","title":"strokeOpacity"},{"location":"troika-three-text/#strokewidth","text":"Sets the width of a stroke drawn inside the edge of each text glyph, using the strokeColor and strokeOpacity . The width can be specified as either an absolute number in local units, or as a percentage string e.g. \"10%\" which is interpreted as a percentage of the fontSize . Default: 0","title":"strokeWidth"},{"location":"troika-three-text/#textalign","text":"The horizontal alignment of each line of text within the overall text bounding box. Can be one of 'left' , 'right' , 'center' , or 'justify' . Default: 'left'","title":"textAlign"},{"location":"troika-three-text/#textindent","text":"An indentation applied to the first character of each hard newline. Behaves like CSS text-indent . Default: 0","title":"textIndent"},{"location":"troika-three-text/#whitespace","text":"Defines whether text should wrap when a line reaches the maxWidth . Can be either 'normal' , to allow wrapping according to the overflowWrap property, or 'nowrap' to prevent wrapping. Note that 'normal' in this context does honor newline characters to manually break lines, making it behave more like 'pre-wrap' does in CSS. Default: 'normal'","title":"whiteSpace"},{"location":"troika-three-text/#handling-asynchronous-updates","text":"Since the text processing occurs in a web worker, it is by definition asynchronous. This means that you can't rely on the text being visible or having a complete geometry immediately. If you need to do things like access the geometry's boundingSphere or the textRenderInfo , you will have to listen for completion. You can do this two ways: Pass a callback function when you call the sync method: myText . sync (() => { // code to execute after sync completes... }) This is best when you want to only react to that specific sync call. Keep in mind that the callback will not execute if the text is already fully synced. Add a listener for the synccomplete event: myText . addEventListener ( 'synccomplete' , () => { // code to execute after sync completes... }) This will fire after every sync, no matter who invoked it. This is best if you need to react to all syncs, for example to trigger a manual canvas render. You can also listen for the syncstart event if you need to react to the initiation of a sync call, e.g. to set some sort of \"waiting\" state while the text is being processed.","title":"Handling Asynchronous Updates"},{"location":"troika-three-text/#preloading","text":"To avoid long pauses when first displaying a piece of text in your scene, you can preload fonts and optionally pre-generate the SDF textures for particular glyphs up front: import { preloadFont } from 'troika-three-text' myApp . showLoadingScreen () preloadFont ( { font : 'path/to/myfontfile.woff' , characters : 'abcdefghijklmnopqrstuvwxyz' }, () => { myApp . showScene () } ) The arguments are: options options.font - The URL of the font file to preload. If null is passed, this will preload the default font. options.characters - A string or array of string character sequences for which to pre-generate glyph SDF textures. Note that this will honor ligature substitution, so you may need to specify ligature sequences in addition to their individual characters to get all possible glyphs, e.g. [\"t\", \"h\", \"th\"] to get the \"t\" and \"h\" glyphs plus the \"th\" glyph. options.sdfGlyphSize - The size at which to prerender the SDFs for the characters glyphs. See the sdfGlyphSize config property on Text for details about SDF sizes. If not specified, will use the default SDF size. callback - A function that will be called when the preloading is complete.","title":"Preloading"},{"location":"troika-three-text/#postprocessing","text":"It is possible to use Text within scenes that utilize the postprocessing library for applying image effects. However, you must enable a special mode in that library that allows Text 's custom material to be honored. Just do the following once somewhere in your code: import { OverrideMaterialManager } from 'postprocessing' OverrideMaterialManager . workaroundEnabled = true","title":"Postprocessing"},{"location":"troika-three-text/#carets-and-selection-ranges","text":"In addition to rendering text, it is possible to access positioning information for caret placement and selection ranges. To access that info, use the getCaretAtPoint and getSelectionRects utility functions. Both of these functions take a textRenderInfo object as input, which you can get from the Text object's textRenderInfo property after sync has completed. See \"Handling Asynchronous Updates\" above for how to react to sync completion events.","title":"Carets and Selection Ranges"},{"location":"troika-three-text/#getcaretatpointtextrenderinfo-x-y","text":"This returns the caret position nearest to a given x/y position in the local text plane. This is useful for placing an editing caret based on a click or ther raycasted event. The return value is an object with the following properties: x - x position of the caret y - y position of the caret's bottom height - height of the caret, based on the current fontSize and lineHeight charIndex - the index in the original input string of this caret's target character. The caret will be for the position before that character. For the final caret position, this will be equal to the string length. For ligature glyphs, this will be for the first character in the ligature sequence.","title":"getCaretAtPoint(textRenderInfo, x, y)"},{"location":"troika-three-text/#getselectionrectstextrenderinfo-start-end","text":"This returns a list of rectangles covering all the characters within a given character range. This is useful for highlighting a selection range. The return value is an array of objects, each with {left, top, right, bottom} properties in the local text plane.","title":"getSelectionRects(textRenderInfo, start, end)"},{"location":"troika-three-utils/BezierMesh/","text":"BezierMesh \u00b6 This is a Three.js object which bends a cylindrical mesh along a 3D cubic bezier path between two points. This is useful for drawing nicely curved lines in 3D space, where the lines have thickness. Rather than assembling a BufferGeometry on the CPU, BezierMesh bends the tube on the GPU in a custom derived vertex shader. This makes it very good for situations where the line's endpoints and control points change over time. They can even be animated every frame without penalty. It can also have any material assigned to it, so it can have lighting, textures, etc. like any other mesh. It will automatically upgrade that material behind the scenes to apply the extra vertex shader transformation. Source code with JSDoc Online example Online example using InstancedUniformsMesh Usage: \u00b6 import { BezierMesh } from 'troika-three-utils' const bezier = new BezierMesh () bezier . pointA . set ( - 0.3 , 0.4 , - 0.3 ) bezier . controlA . set ( 0.7 , 0.6 , 0.4 ) bezier . controlB . set ( - 0.6 , - 0.6 , - 0.6 ) bezier . pointB . set ( 0.7 , 0 , - 0.7 ) bezier . radius = 0.01 scene . add ( bezier ) Supported Properties: \u00b6 pointA \u00b6 A Vector3 holding the position of the first endpoint. controlA \u00b6 A Vector3 holding the position of the first control point. controlB \u00b6 A Vector3 holding the position of the second control point. pointB \u00b6 A Vector3 holding the position of the second endpoint. radius \u00b6 A number defining the radius of the tube. dashArray \u00b6 An array of two numbers, defining the length of \"on\" and \"off\" parts of a dashed line style. Each number is a 0-1 ratio of the entire path's length. (Actually this is the t length used as input to the cubic bezier function, not its visible length.) Note that the dashes will appear like a hollow tube, not solid; this will be more apparent on thicker tubes. dashOffset \u00b6 A numeric offset of where the dash starts. You can animate this to make the dashes move.","title":"BezierMesh"},{"location":"troika-three-utils/BezierMesh/#beziermesh","text":"This is a Three.js object which bends a cylindrical mesh along a 3D cubic bezier path between two points. This is useful for drawing nicely curved lines in 3D space, where the lines have thickness. Rather than assembling a BufferGeometry on the CPU, BezierMesh bends the tube on the GPU in a custom derived vertex shader. This makes it very good for situations where the line's endpoints and control points change over time. They can even be animated every frame without penalty. It can also have any material assigned to it, so it can have lighting, textures, etc. like any other mesh. It will automatically upgrade that material behind the scenes to apply the extra vertex shader transformation. Source code with JSDoc Online example Online example using InstancedUniformsMesh","title":"BezierMesh"},{"location":"troika-three-utils/BezierMesh/#usage","text":"import { BezierMesh } from 'troika-three-utils' const bezier = new BezierMesh () bezier . pointA . set ( - 0.3 , 0.4 , - 0.3 ) bezier . controlA . set ( 0.7 , 0.6 , 0.4 ) bezier . controlB . set ( - 0.6 , - 0.6 , - 0.6 ) bezier . pointB . set ( 0.7 , 0 , - 0.7 ) bezier . radius = 0.01 scene . add ( bezier )","title":"Usage:"},{"location":"troika-three-utils/BezierMesh/#supported-properties","text":"","title":"Supported Properties:"},{"location":"troika-three-utils/BezierMesh/#pointa","text":"A Vector3 holding the position of the first endpoint.","title":"pointA"},{"location":"troika-three-utils/BezierMesh/#controla","text":"A Vector3 holding the position of the first control point.","title":"controlA"},{"location":"troika-three-utils/BezierMesh/#controlb","text":"A Vector3 holding the position of the second control point.","title":"controlB"},{"location":"troika-three-utils/BezierMesh/#pointb","text":"A Vector3 holding the position of the second endpoint.","title":"pointB"},{"location":"troika-three-utils/BezierMesh/#radius","text":"A number defining the radius of the tube.","title":"radius"},{"location":"troika-three-utils/BezierMesh/#dasharray","text":"An array of two numbers, defining the length of \"on\" and \"off\" parts of a dashed line style. Each number is a 0-1 ratio of the entire path's length. (Actually this is the t length used as input to the cubic bezier function, not its visible length.) Note that the dashes will appear like a hollow tube, not solid; this will be more apparent on thicker tubes.","title":"dashArray"},{"location":"troika-three-utils/BezierMesh/#dashoffset","text":"A numeric offset of where the dash starts. You can animate this to make the dashes move.","title":"dashOffset"},{"location":"troika-three-utils/createDerivedMaterial/","text":"Three.js Derived Materials \u00b6 How to use Troika's createDerivedMaterial utility to extend existing Three.js materials with custom shader code Source code with JSDoc One of the most powerful things about Three.js is its excellent set of built-in materials. They provide many features like physically-based reflectivity, shadows, texture maps, fog, and so on, building the very complex shaders behind the scenes. But sometimes you need to do something custom in the shaders, such as move around the vertices, or change the colors or transparency of certain pixels. You could use a ShaderMaterial but then you lose all the built-in features. The experimental NodeMaterial seems promising but doesn't appear to be ready as a full replacement. The onBeforeCompile hook lets you intercept the shader code and modify it, but in practice there are quirks to this that make it difficult to work with, not to mention the complexity of forming regular expressions to inject your custom shader code in the right places. Troika's createDerivedMaterial(baseMaterial, options) utility handles all that complexity, letting you \"extend\" a built-in Material's shaders via a declarative interface. The resulting material can be prototype-chained to the base material so it picks up changes to its properties. It has methods for generating depth and distance materials so your shader modifications can be reflected in shadow maps. Lastly, you can create a derived material from another derived material , and so on. This enables composable patterns where you can piece in small bits of shader logic one at a time. Here's a simple example that injects an auto-incrementing elapsed uniform holding the current time, and uses that to transform the vertices in a wave pattern. import { createDerivedMaterial } from 'troika-three-utils' import { Mesh , MeshStandardMaterial , PlaneBufferGeometry } from 'three' const baseMaterial = new MeshStandardMaterial ({ color : 0xffcc00 }) const customMaterial = createDerivedMaterial ( baseMaterial , { timeUniform : 'elapsed' , // Add GLSL to tweak the vertex... notice this modifies the `position` // and `normal` attributes, which is normally not possible! vertexTransform : ` float waveAmplitude = 0.1 float waveX = uv.x * PI * 4.0 - mod(elapsed / 300.0, PI2); float waveZ = sin(waveX) * waveAmplitude; normal.xyz = normalize(vec3(-cos(waveX) * waveAmplitude, 0.0, 1.0)); position.z += waveZ; ` } ) const mesh = new Mesh ( new PlaneBufferGeometry ( 1 , 1 , 64 , 1 ), customMaterial ) // to enable directional light shadows: mesh . castShadow = true mesh . customDepthMaterial = customMaterial . getDepthMaterial () You can also declare custom uniforms and defines , inject fragment shader code to modify the output color, etc. See the JSDoc in the DerivedMaterial.js source code for full details.","title":"Derived Materials"},{"location":"troika-three-utils/createDerivedMaterial/#threejs-derived-materials","text":"How to use Troika's createDerivedMaterial utility to extend existing Three.js materials with custom shader code Source code with JSDoc One of the most powerful things about Three.js is its excellent set of built-in materials. They provide many features like physically-based reflectivity, shadows, texture maps, fog, and so on, building the very complex shaders behind the scenes. But sometimes you need to do something custom in the shaders, such as move around the vertices, or change the colors or transparency of certain pixels. You could use a ShaderMaterial but then you lose all the built-in features. The experimental NodeMaterial seems promising but doesn't appear to be ready as a full replacement. The onBeforeCompile hook lets you intercept the shader code and modify it, but in practice there are quirks to this that make it difficult to work with, not to mention the complexity of forming regular expressions to inject your custom shader code in the right places. Troika's createDerivedMaterial(baseMaterial, options) utility handles all that complexity, letting you \"extend\" a built-in Material's shaders via a declarative interface. The resulting material can be prototype-chained to the base material so it picks up changes to its properties. It has methods for generating depth and distance materials so your shader modifications can be reflected in shadow maps. Lastly, you can create a derived material from another derived material , and so on. This enables composable patterns where you can piece in small bits of shader logic one at a time. Here's a simple example that injects an auto-incrementing elapsed uniform holding the current time, and uses that to transform the vertices in a wave pattern. import { createDerivedMaterial } from 'troika-three-utils' import { Mesh , MeshStandardMaterial , PlaneBufferGeometry } from 'three' const baseMaterial = new MeshStandardMaterial ({ color : 0xffcc00 }) const customMaterial = createDerivedMaterial ( baseMaterial , { timeUniform : 'elapsed' , // Add GLSL to tweak the vertex... notice this modifies the `position` // and `normal` attributes, which is normally not possible! vertexTransform : ` float waveAmplitude = 0.1 float waveX = uv.x * PI * 4.0 - mod(elapsed / 300.0, PI2); float waveZ = sin(waveX) * waveAmplitude; normal.xyz = normalize(vec3(-cos(waveX) * waveAmplitude, 0.0, 1.0)); position.z += waveZ; ` } ) const mesh = new Mesh ( new PlaneBufferGeometry ( 1 , 1 , 64 , 1 ), customMaterial ) // to enable directional light shadows: mesh . castShadow = true mesh . customDepthMaterial = customMaterial . getDepthMaterial () You can also declare custom uniforms and defines , inject fragment shader code to modify the output color, etc. See the JSDoc in the DerivedMaterial.js source code for full details.","title":"Three.js Derived Materials"},{"location":"troika-worker-utils/","text":"troika-worker-utils \u00b6 This package provides utilities for making Web Workers easier to use. Worker Modules \u00b6 Troika's \"Worker Modules\" system, exposed by the defineWorkerModule export, allows you to define a function that will be executed with a web worker. This provides a simple interface for moving chunks of logic off the main thread, which can be critical in WebGL/WebXR scenes where frame rate cannot be interrupted by long-running code. Similar utilities like Greenlet have existed for a while. However, defineWorkerModule introduces the ability for worker modules to depend on one another . This means you can define modular chunks of code in separate functions, and then inject them into a worker where they can reference and call each other. defineWorkerModule(options) \u00b6 This function defines a Worker Module. It takes an options object that can contain the following: options.init \u00b6 Required. This is the main function that initializes the module; it will be executed within the Worker the first time it is invoked. If any dependencies are defined, the resolved values of those dependencies will be passed in as arguments. Its return value becomes the module's \"value\". That can be: A function, which can be called any number of times from the main thread by calling the function returned from defineWorkerModule() . Any other value, which will be used as the value passed to the init of other worker modules using it as a dependency. Note: As with any function-in-worker utility, the init function must not use any variables from the parent closure in which it is defined; its internal content must be completely standalone. Any external values you want to use must be passed in as dependencies . options.dependencies \u00b6 An optional array of dependencies required by the init function. Dependencies can be: Primitives like strings, numbers, booleans Functions; these will be stringified and rehydrated within the worker so they must not depend on anything from their parent closures Other worker modules created by defineWorkerModule ; these will be resolved within the worker, and therefore modules that provide functions can be called without having to cross the worker/main thread boundary. options.getTransferables \u00b6 An optional function that will be run in the worker just before posting the response value from a module call back to the main thread. This function will be passed that response value, and if it returns an array then that will be used as the \"transferables\" parameter to postMessage . Use this if there are values in the response that can/should be transfered rather than cloned. options.name \u00b6 An optional descriptive name for this module; this can be useful for debugging (it will be inserted as a comment into the Blob sent to the worker) but is not currently used for anything else. options.workerId \u00b6 By default all modules will run in the same dedicated worker, but if you want to use multiple workers you can pass a workerId string to indicate a specific worker to spawn. Note that each worker is completely standalone and no data or state will be shared between them. If a worker module is used as a dependency by worker modules using different workerId s, then that dependency will be re-registered in each worker. Return Value \u00b6 The value returned by defineWorkerModule is a function. If your options.init returned a function, then this will be how you can invoke that within the worker. Call it, and it will give you a Promise for its return value. Contrived Example \u00b6 import { defineWorkerModule } from 'troika-worker-utils' // A simple module with a value: const workerModuleA = defineWorkerModule ({ init : function () { return Math . PI } }) // A module that depends on the previous module: const workerModuleB = defineWorkerModule ({ dependencies : [ workerModuleA ], init : function ( moduleAValue ) { // moduleAValue here is \"I'm the value of Module A!\" from the first init function // This return function can be invoked by calling workerModuleB in the main thread: let callCount = 0 return function ( arg ) { return `Called module B ${ ++ callCount } times, ` + `with arg \" ${ arg } \". Module A's value was ${ moduleAValue } .` } } }) workerModuleB ( 'foo' ) // \"Called module B 1 times, with arg \"foo\". Module A's value was 3.141592653589793.\" workerModuleB ( 'bar' ) // \"Called module B 2 times, with arg \"bar\". Module A's value was 3.141592653589793.\"","title":"Worker Modules"},{"location":"troika-worker-utils/#troika-worker-utils","text":"This package provides utilities for making Web Workers easier to use.","title":"troika-worker-utils"},{"location":"troika-worker-utils/#worker-modules","text":"Troika's \"Worker Modules\" system, exposed by the defineWorkerModule export, allows you to define a function that will be executed with a web worker. This provides a simple interface for moving chunks of logic off the main thread, which can be critical in WebGL/WebXR scenes where frame rate cannot be interrupted by long-running code. Similar utilities like Greenlet have existed for a while. However, defineWorkerModule introduces the ability for worker modules to depend on one another . This means you can define modular chunks of code in separate functions, and then inject them into a worker where they can reference and call each other.","title":"Worker Modules"},{"location":"troika-worker-utils/#defineworkermoduleoptions","text":"This function defines a Worker Module. It takes an options object that can contain the following:","title":"defineWorkerModule(options)"},{"location":"troika-worker-utils/#optionsinit","text":"Required. This is the main function that initializes the module; it will be executed within the Worker the first time it is invoked. If any dependencies are defined, the resolved values of those dependencies will be passed in as arguments. Its return value becomes the module's \"value\". That can be: A function, which can be called any number of times from the main thread by calling the function returned from defineWorkerModule() . Any other value, which will be used as the value passed to the init of other worker modules using it as a dependency. Note: As with any function-in-worker utility, the init function must not use any variables from the parent closure in which it is defined; its internal content must be completely standalone. Any external values you want to use must be passed in as dependencies .","title":"options.init"},{"location":"troika-worker-utils/#optionsdependencies","text":"An optional array of dependencies required by the init function. Dependencies can be: Primitives like strings, numbers, booleans Functions; these will be stringified and rehydrated within the worker so they must not depend on anything from their parent closures Other worker modules created by defineWorkerModule ; these will be resolved within the worker, and therefore modules that provide functions can be called without having to cross the worker/main thread boundary.","title":"options.dependencies"},{"location":"troika-worker-utils/#optionsgettransferables","text":"An optional function that will be run in the worker just before posting the response value from a module call back to the main thread. This function will be passed that response value, and if it returns an array then that will be used as the \"transferables\" parameter to postMessage . Use this if there are values in the response that can/should be transfered rather than cloned.","title":"options.getTransferables"},{"location":"troika-worker-utils/#optionsname","text":"An optional descriptive name for this module; this can be useful for debugging (it will be inserted as a comment into the Blob sent to the worker) but is not currently used for anything else.","title":"options.name"},{"location":"troika-worker-utils/#optionsworkerid","text":"By default all modules will run in the same dedicated worker, but if you want to use multiple workers you can pass a workerId string to indicate a specific worker to spawn. Note that each worker is completely standalone and no data or state will be shared between them. If a worker module is used as a dependency by worker modules using different workerId s, then that dependency will be re-registered in each worker.","title":"options.workerId"},{"location":"troika-worker-utils/#return-value","text":"The value returned by defineWorkerModule is a function. If your options.init returned a function, then this will be how you can invoke that within the worker. Call it, and it will give you a Promise for its return value.","title":"Return Value"},{"location":"troika-worker-utils/#contrived-example","text":"import { defineWorkerModule } from 'troika-worker-utils' // A simple module with a value: const workerModuleA = defineWorkerModule ({ init : function () { return Math . PI } }) // A module that depends on the previous module: const workerModuleB = defineWorkerModule ({ dependencies : [ workerModuleA ], init : function ( moduleAValue ) { // moduleAValue here is \"I'm the value of Module A!\" from the first init function // This return function can be invoked by calling workerModuleB in the main thread: let callCount = 0 return function ( arg ) { return `Called module B ${ ++ callCount } times, ` + `with arg \" ${ arg } \". Module A's value was ${ moduleAValue } .` } } }) workerModuleB ( 'foo' ) // \"Called module B 1 times, with arg \"foo\". Module A's value was 3.141592653589793.\" workerModuleB ( 'bar' ) // \"Called module B 2 times, with arg \"bar\". Module A's value was 3.141592653589793.\"","title":"Contrived Example"},{"location":"troika-xr/","text":"The troika-xr package adds WebXR capabilities to troika-3d scenes. These capabilities include: UI for launching a WebXR session Stereoscopic camera rendering 6DoF head tracking Controller tracking with pointer raycasting integrated into the main event system A few basic helper facades for things like teleportation and menus Note: while definitely usable, this package is still somewhat lacking in configurability and features. Requests and contributions are welcome. Usage \u00b6 The troika-xr package must be installed in addition to troika-3d . Currently, the only provided entry point for WebXR support is via a React higher-order component named ReactXRAware . This assumes that your Troika scene uses the Canvas3D React component as its entry point, which itself is managed by some parent React component. To inject WebXR support, you need to use the ReactXRAware HOC to wrap that parent React component. The HOC function can also be passed several config properties to customize the XR session it will create. (TODO add details here or link to the source code JSDoc...) Note: The HOC must wrap the Canvas3D 's parent rather than the Canvas3D directly because it is going to provide you with a UI button for launching the XR session, which you must place into the DOM outside the canvas. The wrapped React component will now be provided with a few new props for you to use: xrSupported - a boolean indicating any level of browser support for WebXR. xrSupportedSessionModes - an array of supported XR session modes (currently \"inline\" and/or \"immersive-vr\"). xrSession - a reference to the XRSession object when an XR session is active, or null when there is no active session. You can use this to customize content based on whether the user is in XR or not. xrSessionMode - the current session mode when an XR session is active (currently \"inline\" or \"immersive-vr\"). xrReferenceSpace - a reference to the current XRReferenceSpace when an XR session is active, or null otherwise. xrReferenceSpaceType - the current reference space type (\"bounded-floor\" etc.). xrLauncher - a React element that you should place into your render function, which provides the user a UI button for launching their WebXR session. Example HOC Setup \u00b6 import { ReactXRAware } from './XRAware.js' class App extends React . Component { render () { return < div className = \"my_app\" > < Canvas3D camera = {{ // Camera x/y/z/etc. set here controls its base world position, and // headset 6DoF tracking will be applied relative to that. }} objects = {[ this . props . xrSession ? { // some object that is only present in XR } : null , //...other scene objects ]} /> { // This is the button that lets the user launch into XR! this . props . xrLauncher } < /div> } } export const XRApp = ReactXRAware ( App , { //...XR options }) Interaction Events \u00b6 When in an XR session, hand controllers will be automatically added to the scene and be synchronized to their XRInputSource positions. NOTE: rendering of controllers is currently very basic, with only Oculus controllers and a very basic fallback model. Integration of more controller types is planned. XRInputSources that provide a target ray will automatically be used to raycast objects in the scene, and hits will be mapped to normal pointer events (mouseover/mousemove/drag/etc.) just like on screen. Likewise, controller buttons will map to mousedown/up/click events, and thumbsticks will map to wheel events. This lets you define your events the same way for screens and XR, for the most part. While these events won't have screen-specific properties like clientX , they will always carry a ray property holding the THREE.Ray that triggered the hit. (That's also true for all events in non-XR troika-3d , so it's usually safer to use the ray than things like clientX .) Additionally, each event will have a eventSource property holding a reference to the XRInputSource facade that triggered it. This allows you to distinguish which pointer fired an event when you have two hands pointing at different things.","title":"WebXR"},{"location":"troika-xr/#usage","text":"The troika-xr package must be installed in addition to troika-3d . Currently, the only provided entry point for WebXR support is via a React higher-order component named ReactXRAware . This assumes that your Troika scene uses the Canvas3D React component as its entry point, which itself is managed by some parent React component. To inject WebXR support, you need to use the ReactXRAware HOC to wrap that parent React component. The HOC function can also be passed several config properties to customize the XR session it will create. (TODO add details here or link to the source code JSDoc...) Note: The HOC must wrap the Canvas3D 's parent rather than the Canvas3D directly because it is going to provide you with a UI button for launching the XR session, which you must place into the DOM outside the canvas. The wrapped React component will now be provided with a few new props for you to use: xrSupported - a boolean indicating any level of browser support for WebXR. xrSupportedSessionModes - an array of supported XR session modes (currently \"inline\" and/or \"immersive-vr\"). xrSession - a reference to the XRSession object when an XR session is active, or null when there is no active session. You can use this to customize content based on whether the user is in XR or not. xrSessionMode - the current session mode when an XR session is active (currently \"inline\" or \"immersive-vr\"). xrReferenceSpace - a reference to the current XRReferenceSpace when an XR session is active, or null otherwise. xrReferenceSpaceType - the current reference space type (\"bounded-floor\" etc.). xrLauncher - a React element that you should place into your render function, which provides the user a UI button for launching their WebXR session.","title":"Usage"},{"location":"troika-xr/#example-hoc-setup","text":"import { ReactXRAware } from './XRAware.js' class App extends React . Component { render () { return < div className = \"my_app\" > < Canvas3D camera = {{ // Camera x/y/z/etc. set here controls its base world position, and // headset 6DoF tracking will be applied relative to that. }} objects = {[ this . props . xrSession ? { // some object that is only present in XR } : null , //...other scene objects ]} /> { // This is the button that lets the user launch into XR! this . props . xrLauncher } < /div> } } export const XRApp = ReactXRAware ( App , { //...XR options })","title":"Example HOC Setup"},{"location":"troika-xr/#interaction-events","text":"When in an XR session, hand controllers will be automatically added to the scene and be synchronized to their XRInputSource positions. NOTE: rendering of controllers is currently very basic, with only Oculus controllers and a very basic fallback model. Integration of more controller types is planned. XRInputSources that provide a target ray will automatically be used to raycast objects in the scene, and hits will be mapped to normal pointer events (mouseover/mousemove/drag/etc.) just like on screen. Likewise, controller buttons will map to mousedown/up/click events, and thumbsticks will map to wheel events. This lets you define your events the same way for screens and XR, for the most part. While these events won't have screen-specific properties like clientX , they will always carry a ray property holding the THREE.Ray that triggered the hit. (That's also true for all events in non-XR troika-3d , so it's usually safer to use the ray than things like clientX .) Additionally, each event will have a eventSource property holding a reference to the XRInputSource facade that triggered it. This allows you to distinguish which pointer fired an event when you have two hands pointing at different things.","title":"Interaction Events"}]}